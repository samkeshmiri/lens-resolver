{"version":3,"sources":["../../../src/cronjob/CronjobController.ts"],"sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseControllerV2 as BaseController } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport type {\n  SnapId,\n  ValidatedSnapId,\n  TruncatedSnap,\n  CronjobSpecification,\n} from '@metamask/snaps-utils';\nimport {\n  HandlerType,\n  parseCronExpression,\n  logError,\n} from '@metamask/snaps-utils';\nimport { Duration, inMilliseconds } from '@metamask/utils';\n\nimport type {\n  GetAllSnaps,\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapRemoved,\n  SnapUpdated,\n} from '..';\nimport { getRunnableSnaps, SnapEndowments } from '..';\nimport { getCronjobCaveatJobs } from '../snaps/endowments/cronjob';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions;\n\nexport type CronjobControllerEvents = SnapInstalled | SnapRemoved | SnapUpdated;\n\nexport type CronjobControllerMessenger = RestrictedControllerMessenger<\n  'CronjobController',\n  CronjobControllerActions,\n  CronjobControllerEvents,\n  CronjobControllerActions['type'],\n  CronjobControllerEvents['type']\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n};\n\nexport type Cronjob = {\n  timer?: Timer;\n  id: string;\n  snapId: ValidatedSnapId;\n} & CronjobSpecification;\n\nexport type StoredJobInformation = {\n  lastRun: number;\n};\n\nexport type CronjobControllerState = {\n  jobs: Record<string, StoredJobInformation>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * Use this controller to register and schedule periodically executed jobs\n * using RPC method hooks.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  #messenger: CronjobControllerMessenger;\n\n  #dailyTimer!: Timer;\n\n  #timers: Map<string, Timer>;\n\n  // Mapping from jobId to snapId\n  #snapIds: Map<string, string>;\n\n  constructor({ messenger, state }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        jobs: { persist: true, anonymous: false },\n      },\n      name: controllerName,\n      state: {\n        jobs: {},\n        ...state,\n      },\n    });\n    this.#timers = new Map();\n    this.#snapIds = new Map();\n    this.#messenger = messenger;\n\n    this._handleEventSnapInstalled = this._handleEventSnapInstalled.bind(this);\n    this._handleEventSnapRemoved = this._handleEventSnapRemoved.bind(this);\n    this._handleEventSnapUpdated = this._handleEventSnapUpdated.bind(this);\n\n    // Subscribe to Snap events\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      this._handleEventSnapInstalled,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapRemoved',\n      this._handleEventSnapRemoved,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      this._handleEventSnapUpdated,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.dailyCheckIn().catch((error) => {\n      logError(error);\n    });\n  }\n\n  /**\n   * Retrieve all cronjob specifications for all runnable snaps.\n   *\n   * @returns Array of Cronjob specifications.\n   */\n  private getAllJobs(): Cronjob[] {\n    const snaps = this.messagingSystem.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(snaps);\n\n    const jobs = filteredSnaps.map((snap) => this.getSnapJobs(snap.id));\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return jobs.flat().filter((job) => job !== undefined) as Cronjob[];\n  }\n\n  /**\n   * Retrieve all Cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of Cronjob specifications.\n   */\n  private getSnapJobs(snapId: ValidatedSnapId): Cronjob[] | undefined {\n    const permissions = this.#messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    return definitions?.map((definition, idx) => {\n      return { ...definition, id: `${snapId}-${idx}`, snapId };\n    });\n  }\n\n  /**\n   * Register cron jobs for a given snap by getting specification from a permission caveats.\n   * Once registered, each job will be scheduled.\n   *\n   * @param snapId - ID of a snap.\n   */\n  register(snapId: ValidatedSnapId) {\n    const jobs = this.getSnapJobs(snapId);\n    jobs?.forEach((job) => this.schedule(job));\n  }\n\n  /**\n   * Schedule a new job.\n   * This will interpret the cron expression and tell the timer to execute the job\n   * at the next suitable point in time.\n   * Job last run state will be initialized afterwards.\n   *\n   * Note: Schedule will be skipped if the job's execution time is too far in the future and\n   * will be revisited on a daily check.\n   *\n   * @param job - Cronjob specification.\n   */\n  private schedule(job: Cronjob) {\n    if (this.#timers.has(job.id)) {\n      return;\n    }\n\n    const parsed = parseCronExpression(job.expression);\n    const next = parsed.next();\n    const now = new Date();\n    const ms = next.getTime() - now.getTime();\n\n    // Don't schedule this job yet as it is too far in the future\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.executeCronjob(job).catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#timers.delete(job.id);\n      this.schedule(job);\n    });\n\n    this.updateJobLastRunState(job.id, 0); // 0 for init, never ran actually\n    this.#timers.set(job.id, timer);\n    this.#snapIds.set(job.id, job.snapId);\n  }\n\n  /**\n   * Execute job.\n   *\n   * @param job - Cronjob specification.\n   */\n  private async executeCronjob(job: Cronjob) {\n    this.updateJobLastRunState(job.id, Date.now());\n    await this.#messenger.call('SnapController:handleRequest', {\n      snapId: job.snapId,\n      origin: '',\n      handler: HandlerType.OnCronjob,\n      request: job.request,\n    });\n  }\n\n  /**\n   * Unregister all jobs related to the given snapId.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    const jobs = [...this.#snapIds.entries()].filter(\n      ([_, jobSnapId]) => jobSnapId === snapId,\n    );\n\n    if (jobs.length) {\n      jobs.forEach(([id]) => {\n        const timer = this.#timers.get(id);\n        if (timer) {\n          timer.cancel();\n          this.#timers.delete(id);\n          this.#snapIds.delete(id);\n        }\n      });\n    }\n  }\n\n  /**\n   * Update time of a last run for the Cronjob specified by ID.\n   *\n   * @param jobId - ID of a cron job.\n   * @param lastRun - Unix timestamp when the job was last ran.\n   */\n  private updateJobLastRunState(jobId: string, lastRun: number) {\n    this.update((state) => {\n      state.jobs[jobId] = {\n        lastRun,\n      };\n    });\n  }\n\n  /**\n   * Runs every 24 hours to check if new jobs need to be scheduled.\n   *\n   * This is necesary for longer running jobs that execute with more than 24 hours between them.\n   */\n  async dailyCheckIn() {\n    const jobs = this.getAllJobs();\n\n    for (const job of jobs) {\n      const parsed = parseCronExpression(job.expression);\n      const lastRun = this.state.jobs[job.id]?.lastRun;\n      // If a job was supposed to run while we were shut down but wasn't we run it now\n      if (\n        lastRun !== undefined &&\n        parsed.hasPrev() &&\n        parsed.prev().getTime() > lastRun\n      ) {\n        await this.executeCronjob(job);\n      }\n\n      // Try scheduling, will fail if an existing scheduled job is found\n      this.schedule(job);\n    }\n\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.dailyCheckIn().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n    });\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapInstalled',\n      this._handleEventSnapInstalled,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapRemoved',\n      this._handleEventSnapRemoved,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUpdated',\n      this._handleEventSnapUpdated,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.#snapIds.forEach((snapId) => {\n      this.unregister(snapId);\n    });\n  }\n\n  /**\n   * Handle cron jobs on 'snapInstalled' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapInstalled(snap: TruncatedSnap) {\n    this.register(snap.id);\n  }\n\n  /**\n   * Handle cron jobs on 'snapRemoved' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapRemoved(snap: TruncatedSnap) {\n    this.unregister(snap.id);\n  }\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapUpdated(snap: TruncatedSnap) {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  }\n}\n"],"names":["BaseControllerV2","BaseController","HandlerType","parseCronExpression","logError","Duration","inMilliseconds","getRunnableSnaps","SnapEndowments","getCronjobCaveatJobs","Timer","DAILY_TIMEOUT","Hour","controllerName","CronjobController","getAllJobs","snaps","messagingSystem","call","filteredSnaps","jobs","map","snap","getSnapJobs","id","flat","filter","job","undefined","snapId","permissions","messenger","permission","Cronjob","definitions","definition","idx","register","forEach","schedule","timers","has","parsed","expression","next","now","Date","ms","getTime","timer","start","executeCronjob","catch","error","delete","updateJobLastRunState","set","snapIds","origin","handler","OnCronjob","request","unregister","entries","_","jobSnapId","length","get","cancel","jobId","lastRun","update","state","dailyCheckIn","hasPrev","prev","dailyTimer","destroy","unsubscribe","_handleEventSnapInstalled","_handleEventSnapRemoved","_handleEventSnapUpdated","constructor","metadata","persist","anonymous","name","Map","bind","subscribe"],"mappings":"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"}