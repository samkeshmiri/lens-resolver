{"version":3,"sources":["../../../src/services/AbstractExecutionService.ts"],"sourcesContent":["import ObjectMultiplex from '@metamask/object-multiplex';\nimport type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport type { SnapRpcHook, SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { SNAP_STREAM_NAMES, logError } from '@metamask/snaps-utils';\nimport type { Json, JsonRpcNotification } from '@metamask/utils';\nimport { Duration, isJsonRpcNotification, isObject } from '@metamask/utils';\nimport type {\n  // TODO: Replace with @metamask/utils version after bumping json-rpc-engine\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from 'json-rpc-engine';\nimport { JsonRpcEngine } from 'json-rpc-engine';\nimport { createStreamMiddleware } from 'json-rpc-middleware-stream';\nimport { nanoid } from 'nanoid';\nimport pump from 'pump';\nimport type { Duplex } from 'stream';\n\nimport { log } from '../logging';\nimport { hasTimedOut, withTimeout } from '../utils';\nimport type {\n  ExecutionService,\n  ExecutionServiceMessenger,\n  SnapErrorJson,\n  SnapExecutionData,\n} from './ExecutionService';\n\nconst controllerName = 'ExecutionService';\n\nexport type SetupSnapProvider = (snapId: string, stream: Duplex) => void;\n\nexport type ExecutionServiceArgs = {\n  setupSnapProvider: SetupSnapProvider;\n  messenger: ExecutionServiceMessenger;\n  terminationTimeout?: number;\n};\n\nexport type JobStreams = {\n  command: Duplex;\n  rpc: Duplex;\n  _connection: BasePostMessageStream;\n};\n\nexport type Job<WorkerType> = {\n  id: string;\n  streams: JobStreams;\n  rpcEngine: JsonRpcEngine;\n  worker: WorkerType;\n};\n\nexport abstract class AbstractExecutionService<WorkerType>\n  implements ExecutionService\n{\n  #snapRpcHooks: Map<string, SnapRpcHook>;\n\n  // Cannot be hash private yet because of tests.\n  protected jobs: Map<string, Job<WorkerType>>;\n\n  // Cannot be hash private yet because of tests.\n  private readonly setupSnapProvider: SetupSnapProvider;\n\n  #snapToJobMap: Map<string, string>;\n\n  #jobToSnapMap: Map<string, string>;\n\n  #messenger: ExecutionServiceMessenger;\n\n  #terminationTimeout: number;\n\n  constructor({\n    setupSnapProvider,\n    messenger,\n    terminationTimeout = Duration.Second,\n  }: ExecutionServiceArgs) {\n    this.#snapRpcHooks = new Map();\n    this.jobs = new Map();\n    this.setupSnapProvider = setupSnapProvider;\n    this.#snapToJobMap = new Map();\n    this.#jobToSnapMap = new Map();\n    this.#messenger = messenger;\n    this.#terminationTimeout = terminationTimeout;\n\n    this.registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  private registerMessageHandlers(): void {\n    this.#messenger.registerActionHandler(\n      `${controllerName}:handleRpcRequest`,\n      async (snapId: string, options: SnapRpcHookArgs) =>\n        this.handleRpcRequest(snapId, options),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:executeSnap`,\n      async (snapData: SnapExecutionData) => this.executeSnap(snapData),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateSnap`,\n      async (snapId: string) => this.terminateSnap(snapId),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateAllSnaps`,\n      async () => this.terminateAllSnaps(),\n    );\n  }\n\n  /**\n   * Performs additional necessary work during job termination. **MUST** be\n   * implemented by concrete implementations. See\n   * {@link AbstractExecutionService.terminate} for details.\n   *\n   * @param job - The object corresponding to the job to be terminated.\n   */\n  protected abstract terminateJob(job: Job<WorkerType>): void;\n\n  /**\n   * Terminates the job with the specified ID and deletes all its associated\n   * data. Any subsequent messages targeting the job will fail with an error.\n   * Throws an error if the specified job does not exist, or if termination\n   * fails unexpectedly.\n   *\n   * @param jobId - The id of the job to be terminated.\n   */\n  public async terminate(jobId: string): Promise<void> {\n    const jobWrapper = this.jobs.get(jobId);\n    if (!jobWrapper) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    // Ping worker and tell it to run teardown, continue with termination if it takes too long\n    const result = await withTimeout(\n      this.command(jobId, {\n        jsonrpc: '2.0',\n        method: 'terminate',\n        params: [],\n        id: nanoid(),\n      }),\n      this.#terminationTimeout,\n    );\n\n    if (result === hasTimedOut || result !== 'OK') {\n      // We tried to shutdown gracefully but failed. This probably means the Snap is in infinite loop and\n      // hogging down the whole JS process.\n      // TODO(ritave): It might be doing weird things such as posting a lot of setTimeouts. Add a test to ensure that this behaviour\n      //               doesn't leak into other workers. Especially important in IframeExecutionEnvironment since they all share the same\n      //               JS process.\n      logError(`Job \"${jobId}\" failed to terminate gracefully.`, result);\n    }\n\n    Object.values(jobWrapper.streams).forEach((stream) => {\n      try {\n        !stream.destroyed && stream.destroy();\n        stream.removeAllListeners();\n      } catch (error) {\n        logError('Error while destroying stream', error);\n      }\n    });\n\n    this.terminateJob(jobWrapper);\n\n    this.#removeSnapAndJobMapping(jobId);\n    this.jobs.delete(jobId);\n    log(`Job \"${jobId}\" terminated.`);\n  }\n\n  /**\n   * Initiates a job for a snap.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @returns Information regarding the created job.\n   */\n  protected async initJob(): Promise<Job<WorkerType>> {\n    const jobId = nanoid();\n    const { streams, worker } = await this.initStreams(jobId);\n    const rpcEngine = new JsonRpcEngine();\n\n    const jsonRpcConnection = createStreamMiddleware();\n\n    pump(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);\n\n    rpcEngine.push(jsonRpcConnection.middleware);\n\n    const envMetadata = {\n      id: jobId,\n      streams,\n      rpcEngine,\n      worker,\n    };\n    this.jobs.set(jobId, envMetadata);\n\n    return envMetadata;\n  }\n\n  /**\n   * Sets up the streams for an initiated job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param jobId - The id of the job.\n   * @returns The streams to communicate with the worker and the worker itself.\n   */\n  protected async initStreams(\n    jobId: string,\n  ): Promise<{ streams: JobStreams; worker: WorkerType }> {\n    const { worker, stream: envStream } = await this.initEnvStream(jobId);\n    // Typecast justification: stream type mismatch\n    const mux = setupMultiplex(\n      envStream as unknown as Duplex,\n      `Job: \"${jobId}\"`,\n    );\n\n    const commandStream = mux.createStream(SNAP_STREAM_NAMES.COMMAND);\n\n    // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.\n    // Also keep track of outbound request/responses\n    const notificationHandler = (\n      message:\n        | JsonRpcRequest<unknown>\n        | JsonRpcNotification<Json[] | Record<string, Json>>,\n    ) => {\n      if (!isJsonRpcNotification(message)) {\n        return;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const snapId = this.#jobToSnapMap.get(jobId)!;\n      if (message.method === 'OutboundRequest') {\n        this.#messenger.publish('ExecutionService:outboundRequest', snapId);\n      } else if (message.method === 'OutboundResponse') {\n        this.#messenger.publish('ExecutionService:outboundResponse', snapId);\n      } else if (message.method === 'UnhandledError') {\n        if (isObject(message.params) && message.params.error) {\n          this.#messenger.publish(\n            'ExecutionService:unhandledError',\n            snapId,\n            message.params.error as SnapErrorJson,\n          );\n          commandStream.removeListener('data', notificationHandler);\n        } else {\n          logError(\n            new Error(\n              `Received malformed \"${message.method}\" command stream notification.`,\n            ),\n          );\n        }\n      } else {\n        logError(\n          new Error(\n            `Received unexpected command stream notification \"${message.method}\".`,\n          ),\n        );\n      }\n    };\n\n    commandStream.on('data', notificationHandler);\n    const rpcStream = mux.createStream(SNAP_STREAM_NAMES.JSON_RPC);\n\n    // Typecast: stream type mismatch\n    return {\n      streams: {\n        command: commandStream as unknown as Duplex,\n        rpc: rpcStream,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        _connection: envStream,\n      },\n      worker,\n    };\n  }\n\n  /**\n   * Abstract function implemented by implementing class that spins up a new worker for a job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   */\n  protected abstract initEnvStream(jobId: string): Promise<{\n    worker: WorkerType;\n    stream: BasePostMessageStream;\n  }>;\n\n  /**\n   * Terminates the Snap with the specified ID. May throw an error if\n   * termination unexpectedly fails, but will not fail if no job for the snap\n   * with the specified ID is found.\n   *\n   * @param snapId - The ID of the snap to terminate.\n   */\n  async terminateSnap(snapId: string) {\n    const jobId = this.#snapToJobMap.get(snapId);\n    if (jobId) {\n      await this.terminate(jobId);\n    }\n  }\n\n  async terminateAllSnaps() {\n    await Promise.all(\n      [...this.jobs.keys()].map(async (jobId) => this.terminate(jobId)),\n    );\n    this.#snapRpcHooks.clear();\n  }\n\n  /**\n   * Gets the RPC request handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC request handler for the snap.\n   */\n  private getRpcRequestHandler(snapId: string) {\n    return this.#snapRpcHooks.get(snapId);\n  }\n\n  /**\n   * Initializes and executes a snap, setting up the communication channels to the snap etc.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param snapData - Data needed for Snap execution.\n   * @returns A string `OK` if execution succeeded.\n   * @throws If the execution service returns an error.\n   */\n  async executeSnap(snapData: SnapExecutionData): Promise<string> {\n    if (this.#snapToJobMap.has(snapData.snapId)) {\n      throw new Error(`Snap \"${snapData.snapId}\" is already being executed.`);\n    }\n\n    const job = await this.initJob();\n    this.#mapSnapAndJob(snapData.snapId, job.id);\n\n    // Ping the worker to ensure that it started up\n    await this.command(job.id, {\n      jsonrpc: '2.0',\n      method: 'ping',\n      id: nanoid(),\n    });\n\n    const rpcStream = job.streams.rpc as unknown as Duplex;\n\n    this.setupSnapProvider(snapData.snapId, rpcStream);\n\n    const result = await this.command(job.id, {\n      jsonrpc: '2.0',\n      method: 'executeSnap',\n      params: snapData,\n      id: nanoid(),\n    });\n    this.#createSnapHooks(snapData.snapId, job.id);\n    return result as string;\n  }\n\n  // Cannot be hash private yet because of tests.\n  private async command(\n    jobId: string,\n    message: JsonRpcRequest<unknown>,\n  ): Promise<unknown> {\n    if (typeof message !== 'object') {\n      throw new Error('Must send object.');\n    }\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    log('Parent: Sending Command', message);\n    const response: PendingJsonRpcResponse<unknown> =\n      await job.rpcEngine.handle(message);\n    if (response.error) {\n      throw new Error(response.error.message);\n    }\n    return response.result;\n  }\n\n  #removeSnapHooks(snapId: string) {\n    this.#snapRpcHooks.delete(snapId);\n  }\n\n  #createSnapHooks(snapId: string, workerId: string) {\n    const rpcHook = async ({ origin, handler, request }: SnapRpcHookArgs) => {\n      return await this.command(workerId, {\n        id: nanoid(),\n        jsonrpc: '2.0',\n        method: 'snapRpc',\n        params: {\n          origin,\n          handler,\n          request,\n          target: snapId,\n        },\n      });\n    };\n\n    this.#snapRpcHooks.set(snapId, rpcHook);\n  }\n\n  /**\n   * Gets the job id for a given snap.\n   *\n   * @param snapId - A given snap id.\n   * @returns The ID of the snap's job.\n   */\n  #getJobForSnap(snapId: string): string | undefined {\n    return this.#snapToJobMap.get(snapId);\n  }\n\n  /**\n   * Gets the snap id for a given job.\n   *\n   * @param jobId - A given job id.\n   * @returns The ID of the snap that is running the job.\n   */\n  #getSnapForJob(jobId: string): string | undefined {\n    return this.#jobToSnapMap.get(jobId);\n  }\n\n  #mapSnapAndJob(snapId: string, jobId: string): void {\n    this.#snapToJobMap.set(snapId, jobId);\n    this.#jobToSnapMap.set(jobId, snapId);\n  }\n\n  #removeSnapAndJobMapping(jobId: string): void {\n    const snapId = this.#jobToSnapMap.get(jobId);\n    if (!snapId) {\n      throw new Error(`job: \"${jobId}\" has no mapped snap.`);\n    }\n\n    this.#jobToSnapMap.delete(jobId);\n    this.#snapToJobMap.delete(snapId);\n    this.#removeSnapHooks(snapId);\n  }\n\n  /**\n   * Handle RPC request.\n   *\n   * @param snapId - The ID of the recipient snap.\n   * @param options - Bag of options to pass to the RPC handler.\n   * @returns Promise that can handle the request.\n   */\n  public async handleRpcRequest(\n    snapId: string,\n    options: SnapRpcHookArgs,\n  ): Promise<unknown> {\n    const rpcRequestHandler = await this.getRpcRequestHandler(snapId);\n\n    if (!rpcRequestHandler) {\n      throw new Error(\n        `Snap execution service returned no RPC handler for running snap \"${snapId}\".`,\n      );\n    }\n\n    return rpcRequestHandler(options);\n  }\n}\n\n/**\n * Sets up stream multiplexing for the given stream.\n *\n * @param connectionStream - The stream to mux.\n * @param streamName - The name of the stream, for identification in errors.\n * @returns The multiplexed stream.\n */\nexport function setupMultiplex(\n  connectionStream: Duplex,\n  streamName: string,\n): ObjectMultiplex {\n  const mux = new ObjectMultiplex();\n  pump(\n    connectionStream,\n    // Typecast: stream type mismatch\n    mux as unknown as Duplex,\n    connectionStream,\n    (error) => {\n      if (error) {\n        streamName\n          ? logError(`\"${streamName}\" stream failure.`, error)\n          : logError(error);\n      }\n    },\n  );\n  return mux;\n}\n"],"names":["ObjectMultiplex","SNAP_STREAM_NAMES","logError","Duration","isJsonRpcNotification","isObject","JsonRpcEngine","createStreamMiddleware","nanoid","pump","log","hasTimedOut","withTimeout","controllerName","AbstractExecutionService","registerMessageHandlers","messenger","registerActionHandler","snapId","options","handleRpcRequest","snapData","executeSnap","terminateSnap","terminateAllSnaps","terminate","jobId","jobWrapper","jobs","get","Error","result","command","jsonrpc","method","params","id","terminationTimeout","Object","values","streams","forEach","stream","destroyed","destroy","removeAllListeners","error","terminateJob","removeSnapAndJobMapping","delete","initJob","worker","initStreams","rpcEngine","jsonRpcConnection","push","middleware","envMetadata","set","envStream","initEnvStream","mux","setupMultiplex","commandStream","createStream","COMMAND","notificationHandler","message","jobToSnapMap","publish","removeListener","on","rpcStream","JSON_RPC","rpc","_connection","snapToJobMap","Promise","all","keys","map","snapRpcHooks","clear","getRpcRequestHandler","has","job","mapSnapAndJob","setupSnapProvider","createSnapHooks","response","handle","rpcRequestHandler","constructor","Second","Map","workerId","rpcHook","origin","handler","request","target","removeSnapHooks","connectionStream","streamName"],"mappings":"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"}