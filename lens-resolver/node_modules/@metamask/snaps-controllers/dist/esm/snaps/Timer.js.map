{"version":3,"sources":["../../../src/snaps/Timer.ts"],"sourcesContent":["import { assert } from '@metamask/utils';\n\nexport type TimerStatus = 'stopped' | 'paused' | 'running' | 'finished';\n\nexport class Timer {\n  private state:\n    | { value: 'stopped'; remaining: number }\n    | {\n        value: 'paused';\n        remaining: number;\n        callback: () => void;\n      }\n    | {\n        value: 'running';\n        remaining: number;\n        callback: () => void;\n        start: number;\n        timeout?: unknown;\n      }\n    | { value: 'finished' };\n\n  /**\n   * If `ms` is smaller or equal to zero (including -Infinity), the callback is added to the event loop and executed async immediately\n   * If `ms` is +Infinity the timer never finishes.\n   *\n   * @throws {@link TypeError}. If `ms` is NaN or negative.\n   * @param ms - The number of milliseconds before the callback is called after started.\n   */\n  constructor(ms: number) {\n    assert(\n      !Number.isNaN(ms),\n      new TypeError(\"Can't start a timer with NaN time\"),\n    );\n    assert(ms >= 0, new TypeError(\"Can't start a timer with negative time\"));\n    this.state = { value: 'stopped', remaining: ms };\n  }\n\n  get status(): TimerStatus {\n    return this.state.value;\n  }\n\n  /**\n   * Cancels the currently running timer and marks it finished.\n   *\n   * @throws {@link Error}. If it wasn't running or paused.\n   */\n  cancel() {\n    assert(\n      this.status === 'paused' || this.status === 'running',\n      new Error('Tried to cancel a not running Timer'),\n    );\n    this.onFinish(false);\n  }\n\n  /**\n   * Pauses a currently running timer, allowing it to resume later.\n   *\n   * @throws {@link Error}. If it wasn't running.\n   */\n  pause() {\n    assert(\n      this.state.value === 'running',\n      new Error('Tried to pause a not running Timer'),\n    );\n\n    const { callback, start, timeout, remaining } = this.state;\n\n    timeout !== undefined && clearTimeout(timeout as any);\n    this.state = {\n      value: 'paused',\n      callback,\n      remaining: remaining - (Date.now() - start),\n    };\n  }\n\n  /**\n   * Starts the timer.\n   *\n   * @param callback - The function that will be called after the timer finishes.\n   * @throws {@link Error}. If it was already started.\n   */\n  start(callback: () => void) {\n    assert(\n      this.state.value === 'stopped',\n      new Error('Tried to start an already running Timer'),\n    );\n\n    const { remaining } = this.state;\n    this.state = { value: 'paused', remaining, callback };\n    this.resume();\n  }\n\n  /**\n   * Resumes a currently paused timer.\n   *\n   * @throws {@link Error}. If it wasn't paused.\n   */\n  resume() {\n    assert(\n      this.state.value === 'paused',\n      new Error('Tried to resume not paused Timer'),\n    );\n    const { remaining, callback } = this.state;\n    const start = Date.now();\n\n    let timeout: unknown;\n    // setTimeout returns immediately on +Infinity which we use\n    if (remaining !== Number.POSITIVE_INFINITY) {\n      timeout = setTimeout(() => this.onFinish(true), remaining);\n    }\n\n    this.state = { value: 'running', callback, remaining, start, timeout };\n  }\n\n  private onFinish(shouldCall: boolean) {\n    assert(this.state.value === 'running' || this.state.value === 'paused');\n\n    if (this.state.value === 'running' && this.state.timeout !== undefined) {\n      clearTimeout(this.state.timeout as any);\n    }\n\n    const { callback } = this.state;\n    this.state = { value: 'finished' };\n\n    if (shouldCall) {\n      callback();\n    }\n  }\n}\n"],"names":["assert","Timer","status","state","value","cancel","Error","onFinish","pause","callback","start","timeout","remaining","undefined","clearTimeout","Date","now","resume","Number","POSITIVE_INFINITY","setTimeout","shouldCall","constructor","ms","isNaN","TypeError"],"mappings":";;;;;;;;;;;;;AAAA,SAASA,MAAM,QAAQ,kBAAkB;AAIzC,OAAO,MAAMC;IAiCX,IAAIC,SAAsB;QACxB,OAAO,IAAI,CAACC,KAAK,CAACC,KAAK;IACzB;IAEA;;;;GAIC,GACDC,SAAS;QACPL,OACE,IAAI,CAACE,MAAM,KAAK,YAAY,IAAI,CAACA,MAAM,KAAK,WAC5C,IAAII,MAAM;QAEZ,IAAI,CAACC,QAAQ,CAAC;IAChB;IAEA;;;;GAIC,GACDC,QAAQ;QACNR,OACE,IAAI,CAACG,KAAK,CAACC,KAAK,KAAK,WACrB,IAAIE,MAAM;QAGZ,MAAM,EAAEG,QAAQ,EAAEC,KAAK,EAAEC,OAAO,EAAEC,SAAS,EAAE,GAAG,IAAI,CAACT,KAAK;QAE1DQ,YAAYE,aAAaC,aAAaH;QACtC,IAAI,CAACR,KAAK,GAAG;YACXC,OAAO;YACPK;YACAG,WAAWA,YAAaG,CAAAA,KAAKC,GAAG,KAAKN,KAAI;QAC3C;IACF;IAEA;;;;;GAKC,GACDA,MAAMD,QAAoB,EAAE;QAC1BT,OACE,IAAI,CAACG,KAAK,CAACC,KAAK,KAAK,WACrB,IAAIE,MAAM;QAGZ,MAAM,EAAEM,SAAS,EAAE,GAAG,IAAI,CAACT,KAAK;QAChC,IAAI,CAACA,KAAK,GAAG;YAAEC,OAAO;YAAUQ;YAAWH;QAAS;QACpD,IAAI,CAACQ,MAAM;IACb;IAEA;;;;GAIC,GACDA,SAAS;QACPjB,OACE,IAAI,CAACG,KAAK,CAACC,KAAK,KAAK,UACrB,IAAIE,MAAM;QAEZ,MAAM,EAAEM,SAAS,EAAEH,QAAQ,EAAE,GAAG,IAAI,CAACN,KAAK;QAC1C,MAAMO,QAAQK,KAAKC,GAAG;QAEtB,IAAIL;QACJ,2DAA2D;QAC3D,IAAIC,cAAcM,OAAOC,iBAAiB,EAAE;YAC1CR,UAAUS,WAAW,IAAM,IAAI,CAACb,QAAQ,CAAC,OAAOK;QAClD;QAEA,IAAI,CAACT,KAAK,GAAG;YAAEC,OAAO;YAAWK;YAAUG;YAAWF;YAAOC;QAAQ;IACvE;IAEQJ,SAASc,UAAmB,EAAE;QACpCrB,OAAO,IAAI,CAACG,KAAK,CAACC,KAAK,KAAK,aAAa,IAAI,CAACD,KAAK,CAACC,KAAK,KAAK;QAE9D,IAAI,IAAI,CAACD,KAAK,CAACC,KAAK,KAAK,aAAa,IAAI,CAACD,KAAK,CAACQ,OAAO,KAAKE,WAAW;YACtEC,aAAa,IAAI,CAACX,KAAK,CAACQ,OAAO;QACjC;QAEA,MAAM,EAAEF,QAAQ,EAAE,GAAG,IAAI,CAACN,KAAK;QAC/B,IAAI,CAACA,KAAK,GAAG;YAAEC,OAAO;QAAW;QAEjC,IAAIiB,YAAY;YACdZ;QACF;IACF;IA1GA;;;;;;GAMC,GACDa,YAAYC,EAAU,CAAE;QAvBxB,uBAAQpB,SAAR,KAAA;QAwBEH,OACE,CAACkB,OAAOM,KAAK,CAACD,KACd,IAAIE,UAAU;QAEhBzB,OAAOuB,MAAM,GAAG,IAAIE,UAAU;QAC9B,IAAI,CAACtB,KAAK,GAAG;YAAEC,OAAO;YAAWQ,WAAWW;QAAG;IACjD;AA6FF"}