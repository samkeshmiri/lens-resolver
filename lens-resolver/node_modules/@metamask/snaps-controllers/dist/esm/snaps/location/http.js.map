{"version":3,"sources":["../../../../src/snaps/location/http.ts"],"sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  VirtualFile,\n  HttpSnapIdStruct,\n  NpmSnapFileNames,\n  createSnapManifest,\n  normalizeRelative,\n  parseJson,\n} from '@metamask/snaps-utils';\nimport { assert, assertStruct } from '@metamask/utils';\n\nimport type { SnapLocation } from './location';\n\nexport interface HttpOptions {\n  /**\n   * @default fetch\n   */\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit;\n}\n\nexport class HttpLocation implements SnapLocation {\n  // We keep contents separate because then we can use only one Blob in cache,\n  // which we convert to Uint8Array when actually returning the file.\n  //\n  // That avoids deepCloning file contents.\n  // I imagine ArrayBuffers are copy-on-write optimized, meaning\n  // in most often case we'll only have one file contents in common case.\n  private readonly cache = new Map<\n    string,\n    { file: VirtualFile; contents: Blob }\n  >();\n\n  private validatedManifest?: VirtualFile<SnapManifest>;\n\n  private readonly url: URL;\n\n  private readonly fetchFn: typeof fetch;\n\n  private readonly fetchOptions?: RequestInit;\n\n  constructor(url: URL, opts: HttpOptions = {}) {\n    assertStruct(url.toString(), HttpSnapIdStruct, 'Invalid Snap Id: ');\n    this.fetchFn = opts.fetch ?? globalThis.fetch.bind(globalThis);\n    this.fetchOptions = opts.fetchOptions;\n    this.url = url;\n  }\n\n  async manifest(): Promise<VirtualFile<SnapManifest>> {\n    if (this.validatedManifest) {\n      return this.validatedManifest.clone();\n    }\n\n    // jest-fetch-mock doesn't handle new URL(), we need to convert .toString()\n    const canonicalPath = new URL(\n      NpmSnapFileNames.Manifest,\n      this.url,\n    ).toString();\n\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const contents = await response.text();\n    const manifest = parseJson(contents);\n    const vfile = new VirtualFile<SnapManifest>({\n      value: contents,\n      result: createSnapManifest(manifest),\n      path: NpmSnapFileNames.Manifest,\n      data: { canonicalPath },\n    });\n    this.validatedManifest = vfile;\n\n    return this.manifest();\n  }\n\n  async fetch(path: string): Promise<VirtualFile> {\n    const relativePath = normalizeRelative(path);\n    const cached = this.cache.get(relativePath);\n    if (cached !== undefined) {\n      const { file, contents } = cached;\n      const value = new Uint8Array(await contents.arrayBuffer());\n      const vfile = file.clone();\n      vfile.value = value;\n      return vfile;\n    }\n\n    const canonicalPath = this.toCanonical(relativePath).toString();\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const vfile = new VirtualFile({\n      value: '',\n      path: relativePath,\n      data: { canonicalPath },\n    });\n    const blob = await response.blob();\n    assert(\n      !this.cache.has(relativePath),\n      'Corrupted cache, multiple files with same path.',\n    );\n    this.cache.set(relativePath, { file: vfile, contents: blob });\n\n    return this.fetch(relativePath);\n  }\n\n  get root(): URL {\n    return new URL(this.url);\n  }\n\n  private toCanonical(path: string): URL {\n    assert(!path.startsWith('/'), 'Tried to parse absolute path.');\n    return new URL(path, this.url);\n  }\n}\n"],"names":["VirtualFile","HttpSnapIdStruct","NpmSnapFileNames","createSnapManifest","normalizeRelative","parseJson","assert","assertStruct","HttpLocation","manifest","validatedManifest","clone","canonicalPath","URL","Manifest","url","toString","response","fetchFn","fetchOptions","ok","Error","status","contents","text","vfile","value","result","path","data","fetch","relativePath","cached","cache","get","undefined","file","Uint8Array","arrayBuffer","toCanonical","blob","has","set","root","startsWith","constructor","opts","Map","globalThis","bind"],"mappings":"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"}