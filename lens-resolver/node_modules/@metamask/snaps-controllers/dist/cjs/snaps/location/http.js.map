{"version":3,"sources":["../../../../src/snaps/location/http.ts"],"sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  VirtualFile,\n  HttpSnapIdStruct,\n  NpmSnapFileNames,\n  createSnapManifest,\n  normalizeRelative,\n  parseJson,\n} from '@metamask/snaps-utils';\nimport { assert, assertStruct } from '@metamask/utils';\n\nimport type { SnapLocation } from './location';\n\nexport interface HttpOptions {\n  /**\n   * @default fetch\n   */\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit;\n}\n\nexport class HttpLocation implements SnapLocation {\n  // We keep contents separate because then we can use only one Blob in cache,\n  // which we convert to Uint8Array when actually returning the file.\n  //\n  // That avoids deepCloning file contents.\n  // I imagine ArrayBuffers are copy-on-write optimized, meaning\n  // in most often case we'll only have one file contents in common case.\n  private readonly cache = new Map<\n    string,\n    { file: VirtualFile; contents: Blob }\n  >();\n\n  private validatedManifest?: VirtualFile<SnapManifest>;\n\n  private readonly url: URL;\n\n  private readonly fetchFn: typeof fetch;\n\n  private readonly fetchOptions?: RequestInit;\n\n  constructor(url: URL, opts: HttpOptions = {}) {\n    assertStruct(url.toString(), HttpSnapIdStruct, 'Invalid Snap Id: ');\n    this.fetchFn = opts.fetch ?? globalThis.fetch.bind(globalThis);\n    this.fetchOptions = opts.fetchOptions;\n    this.url = url;\n  }\n\n  async manifest(): Promise<VirtualFile<SnapManifest>> {\n    if (this.validatedManifest) {\n      return this.validatedManifest.clone();\n    }\n\n    // jest-fetch-mock doesn't handle new URL(), we need to convert .toString()\n    const canonicalPath = new URL(\n      NpmSnapFileNames.Manifest,\n      this.url,\n    ).toString();\n\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const contents = await response.text();\n    const manifest = parseJson(contents);\n    const vfile = new VirtualFile<SnapManifest>({\n      value: contents,\n      result: createSnapManifest(manifest),\n      path: NpmSnapFileNames.Manifest,\n      data: { canonicalPath },\n    });\n    this.validatedManifest = vfile;\n\n    return this.manifest();\n  }\n\n  async fetch(path: string): Promise<VirtualFile> {\n    const relativePath = normalizeRelative(path);\n    const cached = this.cache.get(relativePath);\n    if (cached !== undefined) {\n      const { file, contents } = cached;\n      const value = new Uint8Array(await contents.arrayBuffer());\n      const vfile = file.clone();\n      vfile.value = value;\n      return vfile;\n    }\n\n    const canonicalPath = this.toCanonical(relativePath).toString();\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const vfile = new VirtualFile({\n      value: '',\n      path: relativePath,\n      data: { canonicalPath },\n    });\n    const blob = await response.blob();\n    assert(\n      !this.cache.has(relativePath),\n      'Corrupted cache, multiple files with same path.',\n    );\n    this.cache.set(relativePath, { file: vfile, contents: blob });\n\n    return this.fetch(relativePath);\n  }\n\n  get root(): URL {\n    return new URL(this.url);\n  }\n\n  private toCanonical(path: string): URL {\n    assert(!path.startsWith('/'), 'Tried to parse absolute path.');\n    return new URL(path, this.url);\n  }\n}\n"],"names":["HttpLocation","manifest","validatedManifest","clone","canonicalPath","URL","NpmSnapFileNames","Manifest","url","toString","response","fetchFn","fetchOptions","ok","Error","status","contents","text","parseJson","vfile","VirtualFile","value","result","createSnapManifest","path","data","fetch","relativePath","normalizeRelative","cached","cache","get","undefined","file","Uint8Array","arrayBuffer","toCanonical","blob","assert","has","set","root","startsWith","constructor","opts","Map","assertStruct","HttpSnapIdStruct","globalThis","bind"],"mappings":"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"}