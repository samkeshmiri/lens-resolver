{"version":3,"sources":["../../../src/cronjob/CronjobController.ts"],"sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseControllerV2 as BaseController } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport type {\n  SnapId,\n  ValidatedSnapId,\n  TruncatedSnap,\n  CronjobSpecification,\n} from '@metamask/snaps-utils';\nimport {\n  HandlerType,\n  parseCronExpression,\n  logError,\n} from '@metamask/snaps-utils';\nimport { Duration, inMilliseconds } from '@metamask/utils';\n\nimport type {\n  GetAllSnaps,\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapRemoved,\n  SnapUpdated,\n} from '..';\nimport { getRunnableSnaps, SnapEndowments } from '..';\nimport { getCronjobCaveatJobs } from '../snaps/endowments/cronjob';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions;\n\nexport type CronjobControllerEvents = SnapInstalled | SnapRemoved | SnapUpdated;\n\nexport type CronjobControllerMessenger = RestrictedControllerMessenger<\n  'CronjobController',\n  CronjobControllerActions,\n  CronjobControllerEvents,\n  CronjobControllerActions['type'],\n  CronjobControllerEvents['type']\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n};\n\nexport type Cronjob = {\n  timer?: Timer;\n  id: string;\n  snapId: ValidatedSnapId;\n} & CronjobSpecification;\n\nexport type StoredJobInformation = {\n  lastRun: number;\n};\n\nexport type CronjobControllerState = {\n  jobs: Record<string, StoredJobInformation>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * Use this controller to register and schedule periodically executed jobs\n * using RPC method hooks.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  #messenger: CronjobControllerMessenger;\n\n  #dailyTimer!: Timer;\n\n  #timers: Map<string, Timer>;\n\n  // Mapping from jobId to snapId\n  #snapIds: Map<string, string>;\n\n  constructor({ messenger, state }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        jobs: { persist: true, anonymous: false },\n      },\n      name: controllerName,\n      state: {\n        jobs: {},\n        ...state,\n      },\n    });\n    this.#timers = new Map();\n    this.#snapIds = new Map();\n    this.#messenger = messenger;\n\n    this._handleEventSnapInstalled = this._handleEventSnapInstalled.bind(this);\n    this._handleEventSnapRemoved = this._handleEventSnapRemoved.bind(this);\n    this._handleEventSnapUpdated = this._handleEventSnapUpdated.bind(this);\n\n    // Subscribe to Snap events\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      this._handleEventSnapInstalled,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapRemoved',\n      this._handleEventSnapRemoved,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      this._handleEventSnapUpdated,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.dailyCheckIn().catch((error) => {\n      logError(error);\n    });\n  }\n\n  /**\n   * Retrieve all cronjob specifications for all runnable snaps.\n   *\n   * @returns Array of Cronjob specifications.\n   */\n  private getAllJobs(): Cronjob[] {\n    const snaps = this.messagingSystem.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(snaps);\n\n    const jobs = filteredSnaps.map((snap) => this.getSnapJobs(snap.id));\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return jobs.flat().filter((job) => job !== undefined) as Cronjob[];\n  }\n\n  /**\n   * Retrieve all Cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of Cronjob specifications.\n   */\n  private getSnapJobs(snapId: ValidatedSnapId): Cronjob[] | undefined {\n    const permissions = this.#messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    return definitions?.map((definition, idx) => {\n      return { ...definition, id: `${snapId}-${idx}`, snapId };\n    });\n  }\n\n  /**\n   * Register cron jobs for a given snap by getting specification from a permission caveats.\n   * Once registered, each job will be scheduled.\n   *\n   * @param snapId - ID of a snap.\n   */\n  register(snapId: ValidatedSnapId) {\n    const jobs = this.getSnapJobs(snapId);\n    jobs?.forEach((job) => this.schedule(job));\n  }\n\n  /**\n   * Schedule a new job.\n   * This will interpret the cron expression and tell the timer to execute the job\n   * at the next suitable point in time.\n   * Job last run state will be initialized afterwards.\n   *\n   * Note: Schedule will be skipped if the job's execution time is too far in the future and\n   * will be revisited on a daily check.\n   *\n   * @param job - Cronjob specification.\n   */\n  private schedule(job: Cronjob) {\n    if (this.#timers.has(job.id)) {\n      return;\n    }\n\n    const parsed = parseCronExpression(job.expression);\n    const next = parsed.next();\n    const now = new Date();\n    const ms = next.getTime() - now.getTime();\n\n    // Don't schedule this job yet as it is too far in the future\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.executeCronjob(job).catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#timers.delete(job.id);\n      this.schedule(job);\n    });\n\n    this.updateJobLastRunState(job.id, 0); // 0 for init, never ran actually\n    this.#timers.set(job.id, timer);\n    this.#snapIds.set(job.id, job.snapId);\n  }\n\n  /**\n   * Execute job.\n   *\n   * @param job - Cronjob specification.\n   */\n  private async executeCronjob(job: Cronjob) {\n    this.updateJobLastRunState(job.id, Date.now());\n    await this.#messenger.call('SnapController:handleRequest', {\n      snapId: job.snapId,\n      origin: '',\n      handler: HandlerType.OnCronjob,\n      request: job.request,\n    });\n  }\n\n  /**\n   * Unregister all jobs related to the given snapId.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    const jobs = [...this.#snapIds.entries()].filter(\n      ([_, jobSnapId]) => jobSnapId === snapId,\n    );\n\n    if (jobs.length) {\n      jobs.forEach(([id]) => {\n        const timer = this.#timers.get(id);\n        if (timer) {\n          timer.cancel();\n          this.#timers.delete(id);\n          this.#snapIds.delete(id);\n        }\n      });\n    }\n  }\n\n  /**\n   * Update time of a last run for the Cronjob specified by ID.\n   *\n   * @param jobId - ID of a cron job.\n   * @param lastRun - Unix timestamp when the job was last ran.\n   */\n  private updateJobLastRunState(jobId: string, lastRun: number) {\n    this.update((state) => {\n      state.jobs[jobId] = {\n        lastRun,\n      };\n    });\n  }\n\n  /**\n   * Runs every 24 hours to check if new jobs need to be scheduled.\n   *\n   * This is necesary for longer running jobs that execute with more than 24 hours between them.\n   */\n  async dailyCheckIn() {\n    const jobs = this.getAllJobs();\n\n    for (const job of jobs) {\n      const parsed = parseCronExpression(job.expression);\n      const lastRun = this.state.jobs[job.id]?.lastRun;\n      // If a job was supposed to run while we were shut down but wasn't we run it now\n      if (\n        lastRun !== undefined &&\n        parsed.hasPrev() &&\n        parsed.prev().getTime() > lastRun\n      ) {\n        await this.executeCronjob(job);\n      }\n\n      // Try scheduling, will fail if an existing scheduled job is found\n      this.schedule(job);\n    }\n\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.dailyCheckIn().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n    });\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapInstalled',\n      this._handleEventSnapInstalled,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapRemoved',\n      this._handleEventSnapRemoved,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUpdated',\n      this._handleEventSnapUpdated,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.#snapIds.forEach((snapId) => {\n      this.unregister(snapId);\n    });\n  }\n\n  /**\n   * Handle cron jobs on 'snapInstalled' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapInstalled(snap: TruncatedSnap) {\n    this.register(snap.id);\n  }\n\n  /**\n   * Handle cron jobs on 'snapRemoved' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapRemoved(snap: TruncatedSnap) {\n    this.unregister(snap.id);\n  }\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  private _handleEventSnapUpdated(snap: TruncatedSnap) {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  }\n}\n"],"names":["DAILY_TIMEOUT","CronjobController","inMilliseconds","Duration","Hour","controllerName","BaseController","getAllJobs","snaps","messagingSystem","call","filteredSnaps","getRunnableSnaps","jobs","map","snap","getSnapJobs","id","flat","filter","job","undefined","snapId","permissions","messenger","permission","SnapEndowments","Cronjob","definitions","getCronjobCaveatJobs","definition","idx","register","forEach","schedule","timers","has","parsed","parseCronExpression","expression","next","now","Date","ms","getTime","timer","Timer","start","executeCronjob","catch","error","logError","delete","updateJobLastRunState","set","snapIds","origin","handler","HandlerType","OnCronjob","request","unregister","entries","_","jobSnapId","length","get","cancel","jobId","lastRun","update","state","dailyCheckIn","hasPrev","prev","dailyTimer","destroy","unsubscribe","_handleEventSnapInstalled","_handleEventSnapRemoved","_handleEventSnapUpdated","constructor","metadata","persist","anonymous","name","Map","bind","subscribe"],"mappings":";;;;;;;;;;;IA0CaA,aAAa;eAAbA;;IA8BAC,iBAAiB;eAAjBA;;;gCAvEsC;4BAY5C;uBACkC;kBASQ;yBACZ;uBACf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBf,MAAMD,gBAAgBE,IAAAA,qBAAc,EAAC,IAAIC,eAAQ,CAACC,IAAI;AAwB7D,MAAMC,iBAAiB;IAWrB,0CAEA,2CAEA,uCAEA,+BAA+B;AAC/B;AAZK,MAAMJ,0BAA0BK,gCAAc;IAyDnD;;;;GAIC,GACD,AAAQC,aAAwB;QAC9B,MAAMC,QAAQ,IAAI,CAACC,eAAe,CAACC,IAAI,CAAC;QACxC,MAAMC,gBAAgBC,IAAAA,kBAAgB,EAACJ;QAEvC,MAAMK,OAAOF,cAAcG,GAAG,CAAC,CAACC,OAAS,IAAI,CAACC,WAAW,CAACD,KAAKE,EAAE;QACjE,4EAA4E;QAC5E,OAAOJ,KAAKK,IAAI,GAAGC,MAAM,CAAC,CAACC,MAAQA,QAAQC;IAC7C;IAEA;;;;;GAKC,GACD,AAAQL,YAAYM,MAAuB,EAAyB;QAClE,MAAMC,cAAc,yBAAA,IAAI,EAAEC,YAAUd,IAAI,CACtC,uCACAY;QAGF,MAAMG,aAAaF,aAAa,CAACG,gBAAc,CAACC,OAAO,CAAC;QACxD,MAAMC,cAAcC,IAAAA,6BAAoB,EAACJ;QAEzC,OAAOG,aAAad,IAAI,CAACgB,YAAYC;YACnC,OAAO;gBAAE,GAAGD,UAAU;gBAAEb,IAAI,CAAC,EAAEK,OAAO,CAAC,EAAES,IAAI,CAAC;gBAAET;YAAO;QACzD;IACF;IAEA;;;;;GAKC,GACDU,SAASV,MAAuB,EAAE;QAChC,MAAMT,OAAO,IAAI,CAACG,WAAW,CAACM;QAC9BT,MAAMoB,QAAQ,CAACb,MAAQ,IAAI,CAACc,QAAQ,CAACd;IACvC;IAEA;;;;;;;;;;GAUC,GACD,AAAQc,SAASd,GAAY,EAAE;QAC7B,IAAI,yBAAA,IAAI,EAAEe,SAAOC,GAAG,CAAChB,IAAIH,EAAE,GAAG;YAC5B;QACF;QAEA,MAAMoB,SAASC,IAAAA,+BAAmB,EAAClB,IAAImB,UAAU;QACjD,MAAMC,OAAOH,OAAOG,IAAI;QACxB,MAAMC,MAAM,IAAIC;QAChB,MAAMC,KAAKH,KAAKI,OAAO,KAAKH,IAAIG,OAAO;QAEvC,6DAA6D;QAC7D,IAAID,KAAK3C,eAAe;YACtB;QACF;QAEA,MAAM6C,QAAQ,IAAIC,YAAK,CAACH;QACxBE,MAAME,KAAK,CAAC;YACV,IAAI,CAACC,cAAc,CAAC5B,KAAK6B,KAAK,CAAC,CAACC;gBAC9B,qCAAqC;gBACrCC,IAAAA,oBAAQ,EAACD;YACX;YAEA,yBAAA,IAAI,EAAEf,SAAOiB,MAAM,CAAChC,IAAIH,EAAE;YAC1B,IAAI,CAACiB,QAAQ,CAACd;QAChB;QAEA,IAAI,CAACiC,qBAAqB,CAACjC,IAAIH,EAAE,EAAE,IAAI,iCAAiC;QACxE,yBAAA,IAAI,EAAEkB,SAAOmB,GAAG,CAAClC,IAAIH,EAAE,EAAE4B;QACzB,yBAAA,IAAI,EAAEU,UAAQD,GAAG,CAAClC,IAAIH,EAAE,EAAEG,IAAIE,MAAM;IACtC;IAEA;;;;GAIC,GACD,MAAc0B,eAAe5B,GAAY,EAAE;QACzC,IAAI,CAACiC,qBAAqB,CAACjC,IAAIH,EAAE,EAAEyB,KAAKD,GAAG;QAC3C,MAAM,yBAAA,IAAI,EAAEjB,YAAUd,IAAI,CAAC,gCAAgC;YACzDY,QAAQF,IAAIE,MAAM;YAClBkC,QAAQ;YACRC,SAASC,uBAAW,CAACC,SAAS;YAC9BC,SAASxC,IAAIwC,OAAO;QACtB;IACF;IAEA;;;;GAIC,GACDC,WAAWvC,MAAc,EAAE;QACzB,MAAMT,OAAO;eAAI,yBAAA,IAAI,EAAE0C,UAAQO,OAAO;SAAG,CAAC3C,MAAM,CAC9C,CAAC,CAAC4C,GAAGC,UAAU,GAAKA,cAAc1C;QAGpC,IAAIT,KAAKoD,MAAM,EAAE;YACfpD,KAAKoB,OAAO,CAAC,CAAC,CAAChB,GAAG;gBAChB,MAAM4B,QAAQ,yBAAA,IAAI,EAAEV,SAAO+B,GAAG,CAACjD;gBAC/B,IAAI4B,OAAO;oBACTA,MAAMsB,MAAM;oBACZ,yBAAA,IAAI,EAAEhC,SAAOiB,MAAM,CAACnC;oBACpB,yBAAA,IAAI,EAAEsC,UAAQH,MAAM,CAACnC;gBACvB;YACF;QACF;IACF;IAEA;;;;;GAKC,GACD,AAAQoC,sBAAsBe,KAAa,EAAEC,OAAe,EAAE;QAC5D,IAAI,CAACC,MAAM,CAAC,CAACC;YACXA,MAAM1D,IAAI,CAACuD,MAAM,GAAG;gBAClBC;YACF;QACF;IACF;IAEA;;;;GAIC,GACD,MAAMG,eAAe;QACnB,MAAM3D,OAAO,IAAI,CAACN,UAAU;QAE5B,KAAK,MAAMa,OAAOP,KAAM;YACtB,MAAMwB,SAASC,IAAAA,+BAAmB,EAAClB,IAAImB,UAAU;YACjD,MAAM8B,UAAU,IAAI,CAACE,KAAK,CAAC1D,IAAI,CAACO,IAAIH,EAAE,CAAC,EAAEoD;YACzC,gFAAgF;YAChF,IACEA,YAAYhD,aACZgB,OAAOoC,OAAO,MACdpC,OAAOqC,IAAI,GAAG9B,OAAO,KAAKyB,SAC1B;gBACA,MAAM,IAAI,CAACrB,cAAc,CAAC5B;YAC5B;YAEA,kEAAkE;YAClE,IAAI,CAACc,QAAQ,CAACd;QAChB;uCAEMuD,aAAa,IAAI7B,YAAK,CAAC9C;QAC7B,yBAAA,IAAI,EAAE2E,aAAW5B,KAAK,CAAC;YACrB,IAAI,CAACyB,YAAY,GAAGvB,KAAK,CAAC,CAACC;gBACzB,qCAAqC;gBACrCC,IAAAA,oBAAQ,EAACD;YACX;QACF;IACF;IAEA;;GAEC,GACD0B,UAAU;QACR,KAAK,CAACA;QAEN,oDAAoD,GACpD,IAAI,CAACnE,eAAe,CAACoE,WAAW,CAC9B,gCACA,IAAI,CAACC,yBAAyB;QAGhC,IAAI,CAACrE,eAAe,CAACoE,WAAW,CAC9B,8BACA,IAAI,CAACE,uBAAuB;QAG9B,IAAI,CAACtE,eAAe,CAACoE,WAAW,CAC9B,8BACA,IAAI,CAACG,uBAAuB;QAE9B,mDAAmD,GAEnD,yBAAA,IAAI,EAAEzB,UAAQtB,OAAO,CAAC,CAACX;YACrB,IAAI,CAACuC,UAAU,CAACvC;QAClB;IACF;IAEA;;;;GAIC,GACD,AAAQwD,0BAA0B/D,IAAmB,EAAE;QACrD,IAAI,CAACiB,QAAQ,CAACjB,KAAKE,EAAE;IACvB;IAEA;;;;GAIC,GACD,AAAQ8D,wBAAwBhE,IAAmB,EAAE;QACnD,IAAI,CAAC8C,UAAU,CAAC9C,KAAKE,EAAE;IACzB;IAEA;;;;GAIC,GACD,AAAQ+D,wBAAwBjE,IAAmB,EAAE;QACnD,IAAI,CAAC8C,UAAU,CAAC9C,KAAKE,EAAE;QACvB,IAAI,CAACe,QAAQ,CAACjB,KAAKE,EAAE;IACvB;IA5QAgE,YAAY,EAAEzD,SAAS,EAAE+C,KAAK,EAAyB,CAAE;QACvD,KAAK,CAAC;YACJ/C;YACA0D,UAAU;gBACRrE,MAAM;oBAAEsE,SAAS;oBAAMC,WAAW;gBAAM;YAC1C;YACAC,MAAMhF;YACNkE,OAAO;gBACL1D,MAAM,CAAC;gBACP,GAAG0D,KAAK;YACV;QACF;QApBF,gCAAA;;mBAAA,KAAA;;QAEA,gCAAA;;mBAAA,KAAA;;QAEA,gCAAA;;mBAAA,KAAA;;QAGA,gCAAA;;mBAAA,KAAA;;uCAcQpC,SAAS,IAAImD;uCACb/B,UAAU,IAAI+B;uCACd9D,YAAYA;QAElB,IAAI,CAACsD,yBAAyB,GAAG,IAAI,CAACA,yBAAyB,CAACS,IAAI,CAAC,IAAI;QACzE,IAAI,CAACR,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACQ,IAAI,CAAC,IAAI;QACrE,IAAI,CAACP,uBAAuB,GAAG,IAAI,CAACA,uBAAuB,CAACO,IAAI,CAAC,IAAI;QAErE,2BAA2B;QAC3B,oDAAoD,GACpD,IAAI,CAAC9E,eAAe,CAAC+E,SAAS,CAC5B,gCACA,IAAI,CAACV,yBAAyB;QAGhC,IAAI,CAACrE,eAAe,CAAC+E,SAAS,CAC5B,8BACA,IAAI,CAACT,uBAAuB;QAG9B,IAAI,CAACtE,eAAe,CAAC+E,SAAS,CAC5B,8BACA,IAAI,CAACR,uBAAuB;QAE9B,mDAAmD,GAEnD,IAAI,CAACR,YAAY,GAAGvB,KAAK,CAAC,CAACC;YACzBC,IAAAA,oBAAQ,EAACD;QACX;IACF;AAoOF"}