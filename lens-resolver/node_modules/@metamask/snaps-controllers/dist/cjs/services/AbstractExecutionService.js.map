{"version":3,"sources":["../../../src/services/AbstractExecutionService.ts"],"sourcesContent":["import ObjectMultiplex from '@metamask/object-multiplex';\nimport type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport type { SnapRpcHook, SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { SNAP_STREAM_NAMES, logError } from '@metamask/snaps-utils';\nimport type { Json, JsonRpcNotification } from '@metamask/utils';\nimport { Duration, isJsonRpcNotification, isObject } from '@metamask/utils';\nimport type {\n  // TODO: Replace with @metamask/utils version after bumping json-rpc-engine\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from 'json-rpc-engine';\nimport { JsonRpcEngine } from 'json-rpc-engine';\nimport { createStreamMiddleware } from 'json-rpc-middleware-stream';\nimport { nanoid } from 'nanoid';\nimport pump from 'pump';\nimport type { Duplex } from 'stream';\n\nimport { log } from '../logging';\nimport { hasTimedOut, withTimeout } from '../utils';\nimport type {\n  ExecutionService,\n  ExecutionServiceMessenger,\n  SnapErrorJson,\n  SnapExecutionData,\n} from './ExecutionService';\n\nconst controllerName = 'ExecutionService';\n\nexport type SetupSnapProvider = (snapId: string, stream: Duplex) => void;\n\nexport type ExecutionServiceArgs = {\n  setupSnapProvider: SetupSnapProvider;\n  messenger: ExecutionServiceMessenger;\n  terminationTimeout?: number;\n};\n\nexport type JobStreams = {\n  command: Duplex;\n  rpc: Duplex;\n  _connection: BasePostMessageStream;\n};\n\nexport type Job<WorkerType> = {\n  id: string;\n  streams: JobStreams;\n  rpcEngine: JsonRpcEngine;\n  worker: WorkerType;\n};\n\nexport abstract class AbstractExecutionService<WorkerType>\n  implements ExecutionService\n{\n  #snapRpcHooks: Map<string, SnapRpcHook>;\n\n  // Cannot be hash private yet because of tests.\n  protected jobs: Map<string, Job<WorkerType>>;\n\n  // Cannot be hash private yet because of tests.\n  private readonly setupSnapProvider: SetupSnapProvider;\n\n  #snapToJobMap: Map<string, string>;\n\n  #jobToSnapMap: Map<string, string>;\n\n  #messenger: ExecutionServiceMessenger;\n\n  #terminationTimeout: number;\n\n  constructor({\n    setupSnapProvider,\n    messenger,\n    terminationTimeout = Duration.Second,\n  }: ExecutionServiceArgs) {\n    this.#snapRpcHooks = new Map();\n    this.jobs = new Map();\n    this.setupSnapProvider = setupSnapProvider;\n    this.#snapToJobMap = new Map();\n    this.#jobToSnapMap = new Map();\n    this.#messenger = messenger;\n    this.#terminationTimeout = terminationTimeout;\n\n    this.registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  private registerMessageHandlers(): void {\n    this.#messenger.registerActionHandler(\n      `${controllerName}:handleRpcRequest`,\n      async (snapId: string, options: SnapRpcHookArgs) =>\n        this.handleRpcRequest(snapId, options),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:executeSnap`,\n      async (snapData: SnapExecutionData) => this.executeSnap(snapData),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateSnap`,\n      async (snapId: string) => this.terminateSnap(snapId),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateAllSnaps`,\n      async () => this.terminateAllSnaps(),\n    );\n  }\n\n  /**\n   * Performs additional necessary work during job termination. **MUST** be\n   * implemented by concrete implementations. See\n   * {@link AbstractExecutionService.terminate} for details.\n   *\n   * @param job - The object corresponding to the job to be terminated.\n   */\n  protected abstract terminateJob(job: Job<WorkerType>): void;\n\n  /**\n   * Terminates the job with the specified ID and deletes all its associated\n   * data. Any subsequent messages targeting the job will fail with an error.\n   * Throws an error if the specified job does not exist, or if termination\n   * fails unexpectedly.\n   *\n   * @param jobId - The id of the job to be terminated.\n   */\n  public async terminate(jobId: string): Promise<void> {\n    const jobWrapper = this.jobs.get(jobId);\n    if (!jobWrapper) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    // Ping worker and tell it to run teardown, continue with termination if it takes too long\n    const result = await withTimeout(\n      this.command(jobId, {\n        jsonrpc: '2.0',\n        method: 'terminate',\n        params: [],\n        id: nanoid(),\n      }),\n      this.#terminationTimeout,\n    );\n\n    if (result === hasTimedOut || result !== 'OK') {\n      // We tried to shutdown gracefully but failed. This probably means the Snap is in infinite loop and\n      // hogging down the whole JS process.\n      // TODO(ritave): It might be doing weird things such as posting a lot of setTimeouts. Add a test to ensure that this behaviour\n      //               doesn't leak into other workers. Especially important in IframeExecutionEnvironment since they all share the same\n      //               JS process.\n      logError(`Job \"${jobId}\" failed to terminate gracefully.`, result);\n    }\n\n    Object.values(jobWrapper.streams).forEach((stream) => {\n      try {\n        !stream.destroyed && stream.destroy();\n        stream.removeAllListeners();\n      } catch (error) {\n        logError('Error while destroying stream', error);\n      }\n    });\n\n    this.terminateJob(jobWrapper);\n\n    this.#removeSnapAndJobMapping(jobId);\n    this.jobs.delete(jobId);\n    log(`Job \"${jobId}\" terminated.`);\n  }\n\n  /**\n   * Initiates a job for a snap.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @returns Information regarding the created job.\n   */\n  protected async initJob(): Promise<Job<WorkerType>> {\n    const jobId = nanoid();\n    const { streams, worker } = await this.initStreams(jobId);\n    const rpcEngine = new JsonRpcEngine();\n\n    const jsonRpcConnection = createStreamMiddleware();\n\n    pump(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);\n\n    rpcEngine.push(jsonRpcConnection.middleware);\n\n    const envMetadata = {\n      id: jobId,\n      streams,\n      rpcEngine,\n      worker,\n    };\n    this.jobs.set(jobId, envMetadata);\n\n    return envMetadata;\n  }\n\n  /**\n   * Sets up the streams for an initiated job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param jobId - The id of the job.\n   * @returns The streams to communicate with the worker and the worker itself.\n   */\n  protected async initStreams(\n    jobId: string,\n  ): Promise<{ streams: JobStreams; worker: WorkerType }> {\n    const { worker, stream: envStream } = await this.initEnvStream(jobId);\n    // Typecast justification: stream type mismatch\n    const mux = setupMultiplex(\n      envStream as unknown as Duplex,\n      `Job: \"${jobId}\"`,\n    );\n\n    const commandStream = mux.createStream(SNAP_STREAM_NAMES.COMMAND);\n\n    // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.\n    // Also keep track of outbound request/responses\n    const notificationHandler = (\n      message:\n        | JsonRpcRequest<unknown>\n        | JsonRpcNotification<Json[] | Record<string, Json>>,\n    ) => {\n      if (!isJsonRpcNotification(message)) {\n        return;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const snapId = this.#jobToSnapMap.get(jobId)!;\n      if (message.method === 'OutboundRequest') {\n        this.#messenger.publish('ExecutionService:outboundRequest', snapId);\n      } else if (message.method === 'OutboundResponse') {\n        this.#messenger.publish('ExecutionService:outboundResponse', snapId);\n      } else if (message.method === 'UnhandledError') {\n        if (isObject(message.params) && message.params.error) {\n          this.#messenger.publish(\n            'ExecutionService:unhandledError',\n            snapId,\n            message.params.error as SnapErrorJson,\n          );\n          commandStream.removeListener('data', notificationHandler);\n        } else {\n          logError(\n            new Error(\n              `Received malformed \"${message.method}\" command stream notification.`,\n            ),\n          );\n        }\n      } else {\n        logError(\n          new Error(\n            `Received unexpected command stream notification \"${message.method}\".`,\n          ),\n        );\n      }\n    };\n\n    commandStream.on('data', notificationHandler);\n    const rpcStream = mux.createStream(SNAP_STREAM_NAMES.JSON_RPC);\n\n    // Typecast: stream type mismatch\n    return {\n      streams: {\n        command: commandStream as unknown as Duplex,\n        rpc: rpcStream,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        _connection: envStream,\n      },\n      worker,\n    };\n  }\n\n  /**\n   * Abstract function implemented by implementing class that spins up a new worker for a job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   */\n  protected abstract initEnvStream(jobId: string): Promise<{\n    worker: WorkerType;\n    stream: BasePostMessageStream;\n  }>;\n\n  /**\n   * Terminates the Snap with the specified ID. May throw an error if\n   * termination unexpectedly fails, but will not fail if no job for the snap\n   * with the specified ID is found.\n   *\n   * @param snapId - The ID of the snap to terminate.\n   */\n  async terminateSnap(snapId: string) {\n    const jobId = this.#snapToJobMap.get(snapId);\n    if (jobId) {\n      await this.terminate(jobId);\n    }\n  }\n\n  async terminateAllSnaps() {\n    await Promise.all(\n      [...this.jobs.keys()].map(async (jobId) => this.terminate(jobId)),\n    );\n    this.#snapRpcHooks.clear();\n  }\n\n  /**\n   * Gets the RPC request handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC request handler for the snap.\n   */\n  private getRpcRequestHandler(snapId: string) {\n    return this.#snapRpcHooks.get(snapId);\n  }\n\n  /**\n   * Initializes and executes a snap, setting up the communication channels to the snap etc.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param snapData - Data needed for Snap execution.\n   * @returns A string `OK` if execution succeeded.\n   * @throws If the execution service returns an error.\n   */\n  async executeSnap(snapData: SnapExecutionData): Promise<string> {\n    if (this.#snapToJobMap.has(snapData.snapId)) {\n      throw new Error(`Snap \"${snapData.snapId}\" is already being executed.`);\n    }\n\n    const job = await this.initJob();\n    this.#mapSnapAndJob(snapData.snapId, job.id);\n\n    // Ping the worker to ensure that it started up\n    await this.command(job.id, {\n      jsonrpc: '2.0',\n      method: 'ping',\n      id: nanoid(),\n    });\n\n    const rpcStream = job.streams.rpc as unknown as Duplex;\n\n    this.setupSnapProvider(snapData.snapId, rpcStream);\n\n    const result = await this.command(job.id, {\n      jsonrpc: '2.0',\n      method: 'executeSnap',\n      params: snapData,\n      id: nanoid(),\n    });\n    this.#createSnapHooks(snapData.snapId, job.id);\n    return result as string;\n  }\n\n  // Cannot be hash private yet because of tests.\n  private async command(\n    jobId: string,\n    message: JsonRpcRequest<unknown>,\n  ): Promise<unknown> {\n    if (typeof message !== 'object') {\n      throw new Error('Must send object.');\n    }\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    log('Parent: Sending Command', message);\n    const response: PendingJsonRpcResponse<unknown> =\n      await job.rpcEngine.handle(message);\n    if (response.error) {\n      throw new Error(response.error.message);\n    }\n    return response.result;\n  }\n\n  #removeSnapHooks(snapId: string) {\n    this.#snapRpcHooks.delete(snapId);\n  }\n\n  #createSnapHooks(snapId: string, workerId: string) {\n    const rpcHook = async ({ origin, handler, request }: SnapRpcHookArgs) => {\n      return await this.command(workerId, {\n        id: nanoid(),\n        jsonrpc: '2.0',\n        method: 'snapRpc',\n        params: {\n          origin,\n          handler,\n          request,\n          target: snapId,\n        },\n      });\n    };\n\n    this.#snapRpcHooks.set(snapId, rpcHook);\n  }\n\n  /**\n   * Gets the job id for a given snap.\n   *\n   * @param snapId - A given snap id.\n   * @returns The ID of the snap's job.\n   */\n  #getJobForSnap(snapId: string): string | undefined {\n    return this.#snapToJobMap.get(snapId);\n  }\n\n  /**\n   * Gets the snap id for a given job.\n   *\n   * @param jobId - A given job id.\n   * @returns The ID of the snap that is running the job.\n   */\n  #getSnapForJob(jobId: string): string | undefined {\n    return this.#jobToSnapMap.get(jobId);\n  }\n\n  #mapSnapAndJob(snapId: string, jobId: string): void {\n    this.#snapToJobMap.set(snapId, jobId);\n    this.#jobToSnapMap.set(jobId, snapId);\n  }\n\n  #removeSnapAndJobMapping(jobId: string): void {\n    const snapId = this.#jobToSnapMap.get(jobId);\n    if (!snapId) {\n      throw new Error(`job: \"${jobId}\" has no mapped snap.`);\n    }\n\n    this.#jobToSnapMap.delete(jobId);\n    this.#snapToJobMap.delete(snapId);\n    this.#removeSnapHooks(snapId);\n  }\n\n  /**\n   * Handle RPC request.\n   *\n   * @param snapId - The ID of the recipient snap.\n   * @param options - Bag of options to pass to the RPC handler.\n   * @returns Promise that can handle the request.\n   */\n  public async handleRpcRequest(\n    snapId: string,\n    options: SnapRpcHookArgs,\n  ): Promise<unknown> {\n    const rpcRequestHandler = await this.getRpcRequestHandler(snapId);\n\n    if (!rpcRequestHandler) {\n      throw new Error(\n        `Snap execution service returned no RPC handler for running snap \"${snapId}\".`,\n      );\n    }\n\n    return rpcRequestHandler(options);\n  }\n}\n\n/**\n * Sets up stream multiplexing for the given stream.\n *\n * @param connectionStream - The stream to mux.\n * @param streamName - The name of the stream, for identification in errors.\n * @returns The multiplexed stream.\n */\nexport function setupMultiplex(\n  connectionStream: Duplex,\n  streamName: string,\n): ObjectMultiplex {\n  const mux = new ObjectMultiplex();\n  pump(\n    connectionStream,\n    // Typecast: stream type mismatch\n    mux as unknown as Duplex,\n    connectionStream,\n    (error) => {\n      if (error) {\n        streamName\n          ? logError(`\"${streamName}\" stream failure.`, error)\n          : logError(error);\n      }\n    },\n  );\n  return mux;\n}\n"],"names":["AbstractExecutionService","setupMultiplex","controllerName","registerMessageHandlers","messenger","registerActionHandler","snapId","options","handleRpcRequest","snapData","executeSnap","terminateSnap","terminateAllSnaps","terminate","jobId","jobWrapper","jobs","get","Error","result","withTimeout","command","jsonrpc","method","params","id","nanoid","terminationTimeout","hasTimedOut","logError","Object","values","streams","forEach","stream","destroyed","destroy","removeAllListeners","error","terminateJob","removeSnapAndJobMapping","delete","log","initJob","worker","initStreams","rpcEngine","JsonRpcEngine","jsonRpcConnection","createStreamMiddleware","pump","push","middleware","envMetadata","set","envStream","initEnvStream","mux","commandStream","createStream","SNAP_STREAM_NAMES","COMMAND","notificationHandler","message","isJsonRpcNotification","jobToSnapMap","publish","isObject","removeListener","on","rpcStream","JSON_RPC","rpc","_connection","snapToJobMap","Promise","all","keys","map","snapRpcHooks","clear","getRpcRequestHandler","has","job","mapSnapAndJob","setupSnapProvider","createSnapHooks","response","handle","rpcRequestHandler","constructor","Duration","Second","Map","workerId","rpcHook","origin","handler","request","target","removeSnapHooks","connectionStream","streamName","ObjectMultiplex"],"mappings":"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"}