"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SnapsWebpackPlugin;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _util = require("util");
const _webpack = require("webpack");
const _webpacksources = require("webpack-sources");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'SnapsWebpackPlugin';
class SnapsWebpackPlugin {
    /**
   * Apply the plugin to the Webpack compiler. Hooks into the `processAssets`
   * stage to process the bundle.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        const { devtool } = compiler.options;
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                stage: _webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY,
                additionalAssets: true
            }, (assets)=>{
                Object.keys(assets).filter((assetName)=>assetName.endsWith('.js')).forEach((assetName)=>{
                    const asset = assets[assetName];
                    const source = asset.source();
                    const sourceMap = asset.map();
                    const processed = (0, _snapsutils.postProcessBundle)(source, {
                        ...this.options,
                        sourceMap: Boolean(devtool),
                        inputSourceMap: devtool ? sourceMap : undefined
                    });
                    if (processed.warnings.length > 0) {
                        compilation.warnings.push(new _webpack.WebpackError(`${PLUGIN_NAME}: Bundle Warning: Processing of the Snap bundle completed with warnings.\n${processed.warnings.join('\n')}`));
                    }
                    const replacement = processed.sourceMap ? new _webpacksources.SourceMapSource(processed.code, assetName, processed.sourceMap, source, sourceMap) : new _webpacksources.RawSource(processed.code);
                    // For some reason the type of `RawSource` is not compatible with
                    // Webpack's own `Source`, but works fine when casting it to `any`.
                    compilation.updateAsset(assetName, replacement);
                });
            });
        });
        compiler.hooks.afterEmit.tapPromise(PLUGIN_NAME, async (compilation)=>{
            const file = compilation.getAssets().find((asset)=>asset.name.endsWith('.js'));
            (0, _utils.assert)(file);
            (0, _utils.assert)(compilation.outputOptions.path);
            const outputPath = compilation.outputOptions.path;
            const filePath = _path.default.join(outputPath, file.name);
            const bundleFile = await (0, _util.promisify)(compiler.outputFileSystem.readFile.bind(compiler.outputFileSystem))(filePath);
            (0, _utils.assert)(bundleFile);
            const bundleContent = bundleFile.toString();
            if (this.options.eval) {
                await (0, _snapsutils.useTemporaryFile)('snaps-bundle.js', bundleContent, (path)=>(0, _snapsutils.evalBundle)(path));
            }
            if (this.options.manifestPath) {
                const { errors, warnings } = await (0, _snapsutils.checkManifest)(_path.default.dirname(this.options.manifestPath), this.options.writeManifest, bundleContent, (0, _util.promisify)(compiler.outputFileSystem.writeFile.bind(compiler.outputFileSystem)));
                if (!this.options.writeManifest && errors.length > 0) {
                    throw new Error(`Manifest Error: The manifest is invalid.\n${errors.join('\n')}`);
                }
                if (warnings.length > 0) {
                    compilation.warnings.push(new _webpack.WebpackError(`${PLUGIN_NAME}: Manifest Warning: Validation of snap.manifest.json completed with warnings.\n${warnings.join('\n')}`));
                }
            }
        });
    }
    /**
   * Construct an instance of the plugin.
   *
   * @param options - The post-process options.
   * @param options.stripComments - Whether to strip comments. Defaults to
   * `true`.
   * @param options.eval - Whether to evaluate the bundle to test SES
   * compatibility. Defaults to `true`.
   * @param options.manifestPath - The path to the manifest file. If provided,
   * the manifest will be validated. Defaults to
   * `process.cwd() + '/snap.manifest.json'`.
   * @param options.writeManifest - Whether to fix the manifest.
   * Defaults to `true`.
   */ constructor(options){
        _define_property(this, "options", void 0);
        this.options = {
            eval: true,
            manifestPath: _path.default.join(process.cwd(), 'snap.manifest.json'),
            writeManifest: true,
            ...options
        };
    }
}

//# sourceMappingURL=plugin.js.map