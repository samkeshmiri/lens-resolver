"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    copyable: function() {
        return copyable;
    },
    divider: function() {
        return divider;
    },
    heading: function() {
        return heading;
    },
    panel: function() {
        return panel;
    },
    spinner: function() {
        return spinner;
    },
    text: function() {
        return text;
    }
});
const _utils = require("@metamask/utils");
const _nodes = require("./nodes");
/**
 * A function that returns a function to "build" a {@link Component}. It infers
 * the type of the component from the given struct, and performs validation on
 * the created component.
 *
 * The returned function can handle the node arguments in two ways:
 * 1. As a single object, with the keys corresponding to the node's properties,
 * excluding the `type` property.
 * 2. As an array of arguments, with the order corresponding to the given keys.
 *
 * @param type - The type of the component to build.
 * @param struct - The struct to use to validate the component.
 * @param keys - The keys of the component to use as arguments to the builder.
 * The order of the keys determines the order of the arguments.
 * @returns A function that builds a component of the given type.
 */ function createBuilder(type, struct, keys = []) {
    return (...args)=>{
        // Node passed as a single object.
        if (args.length === 1 && (0, _utils.isPlainObject)(args[0])) {
            const node = {
                ...args[0],
                type
            };
            // The user could be passing invalid values to the builder, so we need to
            // validate them as per the component's struct.
            (0, _utils.assertStruct)(node, struct, `Invalid ${type} component`);
            return node;
        }
        // Node passed as an array of arguments.
        const node = keys.reduce((partialNode, key, index)=>{
            if (args[index] !== undefined) {
                return {
                    ...partialNode,
                    [key]: args[index]
                };
            }
            return partialNode;
        }, {
            type
        });
        // The user could be passing invalid values to the builder, so we need to
        // validate them as per the component's struct.
        (0, _utils.assertStruct)(node, struct, `Invalid ${type} component`);
        return node;
    };
}
const copyable = createBuilder(_nodes.NodeType.Copyable, _nodes.CopyableStruct, [
    'value'
]);
const divider = createBuilder(_nodes.NodeType.Divider, _nodes.DividerStruct);
const heading = createBuilder(_nodes.NodeType.Heading, _nodes.HeadingStruct, [
    'value'
]);
const panel = createBuilder(_nodes.NodeType.Panel, _nodes.PanelStruct, [
    'children'
]);
const spinner = createBuilder(_nodes.NodeType.Spinner, _nodes.SpinnerStruct);
const text = createBuilder(_nodes.NodeType.Text, _nodes.TextStruct, [
    'value',
    'markdown'
]);

//# sourceMappingURL=builder.js.map