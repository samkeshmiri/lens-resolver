{"version":3,"sources":["../../src/structs.ts"],"sourcesContent":["import { isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport { resolve } from 'path';\nimport type { Failure, Infer } from 'superstruct';\nimport {\n  Struct,\n  StructError,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n  create,\n  string,\n  coerce,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * A wrapper of `superstruct`'s `string` struct that coerces a value to a string\n * and resolves it relative to the current working directory. This is useful\n * for specifying file paths in a configuration file, as it allows the user to\n * use both relative and absolute paths.\n *\n * @returns The `superstruct` struct, which validates that the value is a\n * string, and resolves it relative to the current working directory.\n * @example\n * ```ts\n * const config = struct({\n *   file: file(),\n *   // ...\n * });\n *\n * const value = create({ file: 'path/to/file' }, config);\n * console.log(value.file); // /process/cwd/path/to/file\n * ```\n */\nexport function file() {\n  return coerce(string(), string(), (value) => {\n    return resolve(process.cwd(), value);\n  });\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(struct, [\n      ...failures(),\n    ])}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(struct, prefix, suffix, error, () =>\n    arrayToGenerator(error.failures()),\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => green(type));\n  }\n\n  return null;\n}\n\n/**\n * Get a error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${bold(failure.path.join('.'))} — `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n) {\n  const received = red(JSON.stringify(failure.value));\n  const prefix = getStructErrorPrefix(failure);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(/the literal `(.+)`,/u, `the value to be \\`${green('$1')}\\`,`)\n      .replace(/, but received: (.+)/u, `, but received: ${red('$1')}`);\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${bold(\n      failure.path.join('.'),\n    )}, received: ${received}.`;\n  }\n\n  return `${prefix}Expected a value of type ${green(\n    failure.type,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(`• ${getStructFailureMessage(struct, failure)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n"],"names":["isObject","bold","green","red","resolve","Struct","StructError","define","literal","superstructLiteral","union","superstructUnion","create","string","coerce","indent","value","JSON","stringify","validator","head","tail","struct","schema","file","process","cwd","named","name","type","SnapsStructError","constructor","prefix","suffix","failure","failures","message","getStructErrorMessage","arrayToGenerator","array","item","getError","error","createFromStruct","getStructFromPath","path","reduce","result","key","getUnionStructNames","Array","isArray","map","getStructErrorPrefix","length","join","getStructFailureMessage","received","childStruct","unionNames","replace","formattedFailures"],"mappings":"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"}