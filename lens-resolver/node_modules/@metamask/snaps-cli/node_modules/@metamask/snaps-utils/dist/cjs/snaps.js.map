{"version":3,"sources":["../../src/snaps.ts"],"sourcesContent":["import type {\n  Caveat,\n  SubjectPermissions,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport type { Json, SemVerVersion, Opaque } from '@metamask/utils';\nimport { assert, isObject, assertStruct } from '@metamask/utils';\nimport { base64 } from '@scure/base';\nimport type { SerializedEthereumRpcError } from 'eth-rpc-errors/dist/classes';\nimport stableStringify from 'fast-json-stable-stringify';\nimport type { Struct } from 'superstruct';\nimport {\n  empty,\n  enums,\n  intersection,\n  literal,\n  pattern,\n  refine,\n  string,\n  union,\n  validate,\n} from 'superstruct';\nimport validateNPMPackage from 'validate-npm-package-name';\n\nimport { SnapCaveatType } from './caveats';\nimport { checksumFiles } from './checksum';\nimport type { SnapManifest, SnapPermissions } from './manifest/validation';\nimport type { SnapFiles, SnapId, SnapsPermissionRequest } from './types';\nimport { SnapIdPrefixes, SnapValidationFailureReason, uri } from './types';\nimport type { VirtualFile } from './virtual-file';\n\n// This RegEx matches valid npm package names (with some exceptions) and space-\n// separated alphanumerical words, optionally with dashes and underscores.\n// The RegEx consists of two parts. The first part matches space-separated\n// words. It is based on the following Stackoverflow answer:\n// https://stackoverflow.com/a/34974982\n// The second part, after the pipe operator, is the same RegEx used for the\n// `name` field of the official package.json JSON Schema, except that we allow\n// mixed-case letters. It was originally copied from:\n// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138\nexport const PROPOSED_NAME_REGEX =\n  /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;\n\n/**\n * wallet_enable / wallet_installSnaps permission typing.\n *\n * @deprecated This type is confusing and not descriptive, people confused it with typing initialPermissions, remove when removing wallet_enable.\n */\nexport type RequestedSnapPermissions = {\n  [permission: string]: Record<string, Json>;\n};\n\nexport enum SnapStatus {\n  Installing = 'installing',\n  Updating = 'updating',\n  Running = 'running',\n  Stopped = 'stopped',\n  Crashed = 'crashed',\n}\n\nexport enum SnapStatusEvents {\n  Start = 'START',\n  Stop = 'STOP',\n  Crash = 'CRASH',\n  Update = 'UPDATE',\n}\n\nexport type StatusContext = { snapId: ValidatedSnapId };\nexport type StatusEvents = { type: SnapStatusEvents };\nexport type StatusStates = {\n  value: SnapStatus;\n  context: StatusContext;\n};\nexport type Status = StatusStates['value'];\n\nexport type VersionHistory = {\n  origin: string;\n  version: string;\n  // Unix timestamp\n  date: number;\n};\n\nexport type PersistedSnap = Snap;\n\n/**\n * A Snap as it exists in {@link SnapController} state.\n */\nexport type Snap = {\n  /**\n   * Whether the Snap is enabled, which determines if it can be started.\n   */\n  enabled: boolean;\n\n  /**\n   * The ID of the Snap.\n   */\n  id: ValidatedSnapId;\n\n  /**\n   * The initial permissions of the Snap, which will be requested when it is\n   * installed.\n   */\n  initialPermissions: SnapPermissions;\n\n  /**\n   * The source code of the Snap.\n   */\n  sourceCode: string;\n\n  /**\n   * The Snap's manifest file.\n   */\n  manifest: SnapManifest;\n\n  /**\n   * Whether the Snap is blocked.\n   */\n  blocked: boolean;\n\n  /**\n   * Information detailing why the snap is blocked.\n   */\n  blockInformation?: BlockReason;\n\n  /**\n   * The current status of the Snap, e.g. whether it's running or stopped.\n   */\n  status: Status;\n\n  /**\n   * The version of the Snap.\n   */\n  version: SemVerVersion;\n\n  /**\n   * The version history of the Snap.\n   * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.\n   */\n  versionHistory: VersionHistory[];\n};\n\nexport type TruncatedSnapFields =\n  | 'id'\n  | 'initialPermissions'\n  | 'version'\n  | 'enabled'\n  | 'blocked';\n\n/**\n * A {@link Snap} object with the fields that are relevant to an external\n * caller.\n */\nexport type TruncatedSnap = Pick<Snap, TruncatedSnapFields>;\n\nexport type ProcessSnapResult =\n  | TruncatedSnap\n  | { error: SerializedEthereumRpcError };\n\nexport type InstallSnapsResult = Record<SnapId, ProcessSnapResult>;\n\n/**\n * An error indicating that a Snap validation failure is programmatically\n * fixable during development.\n */\nexport class ProgrammaticallyFixableSnapError extends Error {\n  reason: SnapValidationFailureReason;\n\n  constructor(message: string, reason: SnapValidationFailureReason) {\n    super(message);\n    this.reason = reason;\n  }\n}\n\n/**\n * Gets a checksummable manifest by removing the shasum property and reserializing the JSON using a deterministic algorithm.\n *\n * @param manifest - The manifest itself.\n * @returns A virtual file containing the checksummable manifest.\n */\nfunction getChecksummableManifest(\n  manifest: VirtualFile<SnapManifest>,\n): VirtualFile {\n  const manifestCopy = manifest.clone() as VirtualFile<any>;\n  delete manifestCopy.result.source.shasum;\n\n  // We use fast-json-stable-stringify to deterministically serialize the JSON\n  // This is required before checksumming so we get reproducible checksums across platforms etc\n  manifestCopy.value = stableStringify(manifestCopy.result);\n  return manifestCopy;\n}\n\n/**\n * Calculates the Base64-encoded SHA-256 digest of all required Snap files.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @returns The Base64-encoded SHA-256 digest of the source code.\n */\nexport function getSnapChecksum(\n  files: Pick<SnapFiles, 'manifest' | 'sourceCode' | 'svgIcon'>,\n): string {\n  const { manifest, sourceCode, svgIcon } = files;\n  const all = [getChecksummableManifest(manifest), sourceCode, svgIcon].filter(\n    (file) => file !== undefined,\n  );\n  return base64.encode(checksumFiles(all as VirtualFile[]));\n}\n\n/**\n * Checks whether the `source.shasum` property of a Snap manifest matches the\n * shasum of the snap.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @param errorMessage - The error message to throw if validation fails.\n */\nexport function validateSnapShasum(\n  files: Pick<SnapFiles, 'manifest' | 'sourceCode' | 'svgIcon'>,\n  errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.',\n): void {\n  if (files.manifest.result.source.shasum !== getSnapChecksum(files)) {\n    throw new ProgrammaticallyFixableSnapError(\n      errorMessage,\n      SnapValidationFailureReason.ShasumMismatch,\n    );\n  }\n}\n\nexport const LOCALHOST_HOSTNAMES = ['localhost', '127.0.0.1', '[::1]'] as const;\n\n// Require snap ids to only consist of printable ASCII characters\nexport const BaseSnapIdStruct = pattern(string(), /^[\\x21-\\x7E]*$/u);\n\nconst LocalSnapIdSubUrlStruct = uri({\n  protocol: enums(['http:', 'https:']),\n  hostname: enums(LOCALHOST_HOSTNAMES),\n  hash: empty(string()),\n  search: empty(string()),\n});\nexport const LocalSnapIdStruct = refine(\n  BaseSnapIdStruct,\n  'local Snap Id',\n  (value) => {\n    if (!value.startsWith(SnapIdPrefixes.local)) {\n      return `Expected local snap ID, got \"${value}\".`;\n    }\n\n    const [error] = validate(\n      value.slice(SnapIdPrefixes.local.length),\n      LocalSnapIdSubUrlStruct,\n    );\n    return error ?? true;\n  },\n);\nexport const NpmSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: literal(SnapIdPrefixes.npm),\n    pathname: refine(string(), 'package name', function* (value) {\n      const normalized = value.startsWith('/') ? value.slice(1) : value;\n      const { errors, validForNewPackages, warnings } =\n        validateNPMPackage(normalized);\n      if (!validForNewPackages) {\n        if (errors === undefined) {\n          assert(warnings !== undefined);\n          yield* warnings;\n        } else {\n          yield* errors;\n        }\n      }\n      return true;\n    }),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const HttpSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: enums(['http:', 'https:']),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const SnapIdStruct = union([NpmSnapIdStruct, LocalSnapIdStruct]);\n\nexport type ValidatedSnapId = Opaque<string, typeof snapIdSymbol>;\ndeclare const snapIdSymbol: unique symbol;\n\n/**\n * Extracts the snap prefix from a snap ID.\n *\n * @param snapId - The snap ID to extract the prefix from.\n * @returns The snap prefix from a snap id, e.g. `npm:`.\n */\nexport function getSnapPrefix(snapId: string): SnapIdPrefixes {\n  const prefix = Object.values(SnapIdPrefixes).find((possiblePrefix) =>\n    snapId.startsWith(possiblePrefix),\n  );\n  if (prefix !== undefined) {\n    return prefix;\n  }\n  throw new Error(`Invalid or no prefix found for \"${snapId}\"`);\n}\n\n/**\n * Strips snap prefix from a full snap ID.\n *\n * @param snapId - The snap ID to strip.\n * @returns The stripped snap ID.\n */\nexport function stripSnapPrefix(snapId: string): string {\n  return snapId.replace(getSnapPrefix(snapId), '');\n}\n\n/**\n * Assert that the given value is a valid snap ID.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid snap ID.\n */\nexport function assertIsValidSnapId(\n  value: unknown,\n): asserts value is ValidatedSnapId {\n  assertStruct(value, SnapIdStruct, 'Invalid snap ID');\n}\n\n/**\n * Typeguard to ensure a chainId follows the CAIP-2 standard.\n *\n * @param chainId - The chainId being tested.\n * @returns `true` if the value is a valid CAIP chain id, and `false` otherwise.\n */\nexport function isCaipChainId(chainId: unknown): chainId is string {\n  return (\n    typeof chainId === 'string' &&\n    /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u.test(\n      chainId,\n    )\n  );\n}\n\n/**\n * Utility function to check if an origin has permission (and caveat) for a particular snap.\n *\n * @param permissions - An origin's permissions object.\n * @param snapId - The id of the snap.\n * @returns A boolean based on if an origin has the specified snap.\n */\nexport function isSnapPermitted(\n  permissions: SubjectPermissions<PermissionConstraint>,\n  snapId: SnapId,\n) {\n  return Boolean(\n    (\n      (\n        (permissions?.wallet_snap?.caveats?.find(\n          (caveat) => caveat.type === SnapCaveatType.SnapIds,\n        ) ?? {}) as Caveat<string, Json>\n      ).value as Record<string, unknown>\n    )?.[snapId],\n  );\n}\n\n/**\n * Checks whether the passed in requestedPermissions is a valid\n * permission request for a `wallet_snap` permission.\n *\n * @param requestedPermissions - The requested permissions.\n * @throws If the criteria is not met.\n */\nexport function verifyRequestedSnapPermissions(\n  requestedPermissions: unknown,\n): asserts requestedPermissions is SnapsPermissionRequest {\n  assert(\n    isObject(requestedPermissions),\n    'Requested permissions must be an object.',\n  );\n\n  const { wallet_snap: walletSnapPermission } = requestedPermissions;\n\n  assert(\n    isObject(walletSnapPermission),\n    'wallet_snap is missing from the requested permissions.',\n  );\n\n  const { caveats } = walletSnapPermission;\n\n  assert(\n    Array.isArray(caveats) && caveats.length === 1,\n    'wallet_snap must have a caveat property with a single-item array value.',\n  );\n\n  const [caveat] = caveats;\n\n  assert(\n    isObject(caveat) &&\n      caveat.type === SnapCaveatType.SnapIds &&\n      isObject(caveat.value),\n    `The requested permissions do not have a valid ${SnapCaveatType.SnapIds} caveat.`,\n  );\n}\n"],"names":["PROPOSED_NAME_REGEX","ProgrammaticallyFixableSnapError","getSnapChecksum","validateSnapShasum","LOCALHOST_HOSTNAMES","BaseSnapIdStruct","LocalSnapIdStruct","NpmSnapIdStruct","HttpSnapIdStruct","SnapIdStruct","getSnapPrefix","stripSnapPrefix","assertIsValidSnapId","isCaipChainId","isSnapPermitted","verifyRequestedSnapPermissions","SnapStatus","Installing","Updating","Running","Stopped","Crashed","SnapStatusEvents","Start","Stop","Crash","Update","Error","constructor","message","reason","getChecksummableManifest","manifest","manifestCopy","clone","result","source","shasum","value","stableStringify","files","sourceCode","svgIcon","all","filter","file","undefined","base64","encode","checksumFiles","errorMessage","SnapValidationFailureReason","ShasumMismatch","pattern","string","LocalSnapIdSubUrlStruct","uri","protocol","enums","hostname","hash","empty","search","refine","startsWith","SnapIdPrefixes","local","error","validate","slice","length","intersection","literal","npm","pathname","normalized","errors","validForNewPackages","warnings","validateNPMPackage","assert","union","snapId","prefix","Object","values","find","possiblePrefix","replace","assertStruct","chainId","test","permissions","Boolean","wallet_snap","caveats","caveat","type","SnapCaveatType","SnapIds","requestedPermissions","isObject","walletSnapPermission","Array","isArray"],"mappings":"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"}