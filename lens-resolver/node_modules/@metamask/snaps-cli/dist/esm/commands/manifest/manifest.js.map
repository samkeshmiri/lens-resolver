{"version":3,"sources":["../../../../src/commands/manifest/manifest.ts"],"sourcesContent":["import { isFile } from '@metamask/snaps-utils';\n\nimport type { ProcessedConfig } from '../../config';\nimport { CommandError } from '../../errors';\nimport type { Steps } from '../../utils';\nimport { executeSteps } from '../../utils';\nimport { manifest } from './implementation';\n\ntype ManifestOptions = {\n  fix?: boolean;\n};\n\ntype ManifestContext = {\n  input: string;\n  config: ProcessedConfig;\n  options: ManifestOptions;\n};\n\nconst steps: Steps<ManifestContext> = [\n  {\n    name: 'Checking the input file.',\n    task: async ({ input }) => {\n      if (!(await isFile(input))) {\n        throw new CommandError(\n          `Manifest file not found: \"${input}\". Make sure that the \\`snap.manifest.json\\` file exists.`,\n        );\n      }\n    },\n  },\n  {\n    name: 'Validating the snap manifest.',\n    task: async ({ input, config, options, spinner }) => {\n      const write = getWriteManifest(config, options);\n      const valid = await manifest(input, write, spinner);\n\n      if (valid) {\n        spinner.succeed('The snap manifest file is valid.');\n      }\n    },\n  },\n];\n\n/**\n * Get whether to write the manifest to disk.\n *\n * @param config - The config object.\n * @param options - The options object.\n * @returns Whether to write the manifest to disk.\n */\nfunction getWriteManifest(config: ProcessedConfig, options: ManifestOptions) {\n  if (typeof options.fix === 'boolean') {\n    return options.fix;\n  }\n\n  return config.legacy?.writeManifest ?? false;\n}\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param config - The config object.\n * @param options - The options object.\n */\nexport async function manifestHandler(\n  config: ProcessedConfig,\n  options: ManifestOptions,\n) {\n  await executeSteps(steps, {\n    input: config.manifest.path,\n    config,\n    options,\n  });\n}\n"],"names":["isFile","CommandError","executeSteps","manifest","steps","name","task","input","config","options","spinner","write","getWriteManifest","valid","succeed","fix","legacy","writeManifest","manifestHandler","path"],"mappings":"AAAA,SAASA,MAAM,QAAQ,wBAAwB;AAG/C,SAASC,YAAY,QAAQ,eAAe;AAE5C,SAASC,YAAY,QAAQ,cAAc;AAC3C,SAASC,QAAQ,QAAQ,mBAAmB;AAY5C,MAAMC,QAAgC;IACpC;QACEC,MAAM;QACNC,MAAM,OAAO,EAAEC,KAAK,EAAE;YACpB,IAAI,CAAE,MAAMP,OAAOO,QAAS;gBAC1B,MAAM,IAAIN,aACR,CAAC,0BAA0B,EAAEM,MAAM,yDAAyD,CAAC;YAEjG;QACF;IACF;IACA;QACEF,MAAM;QACNC,MAAM,OAAO,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAE;YAC9C,MAAMC,QAAQC,iBAAiBJ,QAAQC;YACvC,MAAMI,QAAQ,MAAMV,SAASI,OAAOI,OAAOD;YAE3C,IAAIG,OAAO;gBACTH,QAAQI,OAAO,CAAC;YAClB;QACF;IACF;CACD;AAED;;;;;;CAMC,GACD,SAASF,iBAAiBJ,MAAuB,EAAEC,OAAwB;IACzE,IAAI,OAAOA,QAAQM,GAAG,KAAK,WAAW;QACpC,OAAON,QAAQM,GAAG;IACpB;IAEA,OAAOP,OAAOQ,MAAM,EAAEC,iBAAiB;AACzC;AAEA;;;;;;;CAOC,GACD,OAAO,eAAeC,gBACpBV,MAAuB,EACvBC,OAAwB;IAExB,MAAMP,aAAaE,OAAO;QACxBG,OAAOC,OAAOL,QAAQ,CAACgB,IAAI;QAC3BX;QACAC;IACF;AACF"}