function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { indent } from '@metamask/snaps-utils';
import { assert, hasProperty, isObject } from '@metamask/utils';
import { dim, red, yellow } from 'chalk';
import { isBuiltin } from 'module';
import { evaluate } from '../commands/eval';
import { error, getErrorMessage, info, warn } from '../utils';
import { pluralize } from './utils';
var _spinner = /*#__PURE__*/ new WeakMap(), /**
   * Get the error message for the given stats error.
   *
   * @param statsError - The stats error.
   * @returns The error message.
   */ _getStatsErrorMessage = /*#__PURE__*/ new WeakSet();
/**
 * A plugin that logs the stats after compilation. This is useful for logging
 * the number of files compiled, and the time taken to compile them.
 */ export class SnapsStatsPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        compiler.hooks.afterDone.tap(this.constructor.name, (stats)=>{
            if (!stats) {
                return;
            }
            const { modules, time, errors } = stats.toJson();
            assert(modules, 'Modules must be defined in stats.');
            assert(time, 'Time must be defined in stats.');
            if (errors?.length) {
                const formattedErrors = errors.map(_class_private_method_get(this, _getStatsErrorMessage, getStatsErrorMessage).bind(this)).join('\n\n');
                error(`Compiled ${modules.length} ${pluralize(modules.length, 'file')} in ${time}ms with ${errors.length} ${pluralize(errors.length, 'error')}.\n\n${formattedErrors}\n`, _class_private_field_get(this, _spinner));
                _class_private_field_get(this, _spinner)?.stop();
                process.exitCode = 1;
                return;
            }
            info(`Compiled ${modules.length} ${pluralize(modules.length, 'file')} in ${time}ms.`, _class_private_field_get(this, _spinner));
            if (compiler.watchMode) {
                // The spinner may be restarted by the watch plugin, outside of the
                // `executeSteps` flow, so we stop it here just in case.
                _class_private_field_get(this, _spinner)?.succeed('Done!');
            }
        });
    }
    constructor(options = {
        verbose: false
    }, spinner){
        _class_private_method_init(this, _getStatsErrorMessage);
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner, spinner);
    }
}
function getStatsErrorMessage(statsError) {
    const baseMessage = this.options.verbose ? getErrorMessage(statsError) : statsError.message;
    const [first, ...rest] = baseMessage.split('\n');
    return [
        indent(red(`• ${first}`), 2),
        ...rest.map((message)=>indent(red(message), 4)),
        statsError.details && indent(dim(statsError.details), 4)
    ].filter(Boolean).join('\n');
}
var _spinner1 = /*#__PURE__*/ new WeakMap(), _safeEvaluate = /*#__PURE__*/ new WeakSet();
/**
 * A plugin that adds extra files to watch. This is useful for watching files
 * that are not imported by the entry point, such as the `snap.manifest.json`
 * file.
 */ export class SnapsWatchPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        compiler.hooks.invalid.tap(this.constructor.name, (file)=>{
            _class_private_field_get(this, _spinner1)?.start();
            info(`Changes detected in ${yellow(file)}, recompiling.`, _class_private_field_get(this, _spinner1));
        });
        compiler.hooks.afterEmit.tapPromise(this.constructor.name, async ({ fileDependencies })=>{
            this.options.files?.forEach(fileDependencies.add.bind(fileDependencies));
            if (this.options.bundle && this.options.evaluate) {
                await _class_private_method_get(this, _safeEvaluate, safeEvaluate).call(this, this.options.bundle);
            }
        });
    }
    constructor(options, spinner){
        /**
   * Safely evaluate the bundle at the given path. If an error occurs, it will
   * be logged to the console, rather than throwing an error.
   *
   * This function should never throw an error.
   *
   * @param bundlePath - The path to the bundle.
   */ _class_private_method_init(this, _safeEvaluate);
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner1, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner1, spinner);
    }
}
async function safeEvaluate(bundlePath) {
    try {
        await evaluate(bundlePath);
        info(`Snap bundle evaluated successfully.`, _class_private_field_get(this, _spinner1));
    } catch (evaluateError) {
        error(evaluateError.message, _class_private_field_get(this, _spinner1));
    }
}
var _source = /*#__PURE__*/ new WeakMap(), _spinner2 = /*#__PURE__*/ new WeakMap();
/**
 * A plugin that logs a message when a built-in module is not resolved. The
 * MetaMask Snaps CLI does not support built-in modules by default, and this
 * plugin is used to warn the user when they try to import a built-in module,
 * when no fallback is configured.
 */ export class SnapsBuiltInResolver {
    /**
   * Apply the plugin to the Webpack resolver.
   *
   * @param resolver - The Webpack resolver.
   */ apply(resolver) {
        resolver.getHook(_class_private_field_get(this, _source)).tapAsync(this.constructor.name, ({ module: isModule, request }, _, callback)=>{
            if (!isModule || !request) {
                return callback();
            }
            const baseRequest = request.split('/')[0];
            if (isBuiltin(baseRequest) && !this.options.ignore?.includes(baseRequest)) {
                const fallback = resolver.options.fallback.find(({ name })=>name === baseRequest);
                if (fallback && !fallback.alias) {
                    this.unresolvedModules.add(baseRequest);
                }
            }
            return callback();
        });
    }
    constructor(options = {
        ignore: []
    }, spinner){
        /**
   * The built-in modules that have been imported, but not resolved.
   */ _define_property(this, "unresolvedModules", new Set());
        /**
   * The name of the resolver hook to tap into.
   */ _class_private_field_init(this, _source, {
            writable: true,
            value: 'described-resolve'
        });
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner2, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner2, spinner);
    }
}
var _spinner3 = /*#__PURE__*/ new WeakMap(), /**
   * Check if a built-in module is used, but not provided by Webpack's
   * `fallback` configuration.
   *
   * @param compiler - The Webpack compiler.
   */ _checkBuiltIns = /*#__PURE__*/ new WeakSet(), /**
   * Check if the given instance is a `ProvidePlugin`. This is not guaranteed to
   * be accurate, but it's good enough for our purposes. If we were to use
   * `instanceof` instead, it might not work if multiple versions of Webpack are
   * installed.
   *
   * @param instance - The instance to check.
   * @returns Whether the instance is a `ProvidePlugin`, i.e., whether it's an
   * object with the name `ProvidePlugin` and a `definitions` property.
   */ _isProvidePlugin = /*#__PURE__*/ new WeakSet(), /**
   * Check if the `Buffer` global is used, but not provided by Webpack's
   * `DefinePlugin`.
   *
   * @param compiler - The Webpack compiler.
   */ _checkBuffer = /*#__PURE__*/ new WeakSet();
/**
 * A plugin that logs a message when:
 *
 * - A built-in module is not resolved. The MetaMask Snaps CLI does not support
 * built-in modules by default, and this plugin is used to warn the user when
 * they try to import a built-in module, when no fallback is configured.
 * - A snap uses the `Buffer` global. The MetaMask Snaps CLI does not support
 * the `Buffer` global by default, and this plugin is used to warn the user when
 * they try to use the `Buffer` global.
 *
 * We use both a resolver and a plugin, because the resolver is used to detect
 * when a built-in module is imported, and the plugin is used to log a single
 * message when the compilation is complete. We can't do everything in a single
 * plugin, because the resolver doesn't have access to the compilation, and the
 * plugin doesn't have access to the resolver.
 */ export class SnapsBundleWarningsPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        if (this.options.builtIns) {
            _class_private_method_get(this, _checkBuiltIns, checkBuiltIns).call(this, compiler);
        }
        if (this.options.buffer) {
            _class_private_method_get(this, _checkBuffer, checkBuffer).call(this, compiler);
        }
    }
    constructor(options = {
        buffer: true,
        builtIns: true
    }, spinner){
        _class_private_method_init(this, _checkBuiltIns);
        _class_private_method_init(this, _isProvidePlugin);
        _class_private_method_init(this, _checkBuffer);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner3, {
            writable: true,
            value: void 0
        });
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        this.options = options;
        _class_private_field_set(this, _spinner3, spinner);
    }
}
function checkBuiltIns(compiler) {
    compiler.hooks.afterCompile.tap(this.constructor.name, ()=>{
        if (!this.options.builtInResolver) {
            return;
        }
        const { unresolvedModules } = this.options.builtInResolver;
        if (unresolvedModules.size === 0) {
            return;
        }
        const formattedModules = new Array(...unresolvedModules).map((name)=>indent(`• ${name}`, 2)).join('\n');
        warn(`The snap attempted to use one or more Node.js builtins, but no browser fallback has been provided.\n` + `The MetaMask Snaps CLI does not support Node.js builtins by default. If you want to use this module, you must set ${yellow(`polyfills`)} to ${yellow(`true`)} or an object with the builtins to polyfill as the key and ${yellow(`true`)} as the value.\n` + `To disable this warning, set ${yellow('`stats.builtIns`')} to ${yellow('`false`')} in your snap config file, or add the module to the ${yellow('`stats.builtIns.ignore`')} array.\n\n${formattedModules}\n`, _class_private_field_get(this, _spinner3));
    });
}
function isProvidePlugin(instance) {
    return isObject(instance) && instance.constructor.name === 'ProvidePlugin' && hasProperty(instance, 'definitions');
}
function checkBuffer(compiler) {
    const plugin = compiler.options.plugins?.find((instance)=>_class_private_method_get(this, _isProvidePlugin, isProvidePlugin).call(this, instance));
    // If the `ProvidePlugin` is configured to provide `Buffer`, then we don't
    // need to warn the user.
    if (plugin) {
        const { definitions } = plugin;
        if (definitions.Buffer) {
            return;
        }
    }
    compiler.hooks.compilation.tap(this.constructor.name, (compilation)=>{
        compilation.hooks.afterProcessAssets.tap(this.constructor.name, (assets)=>{
            // Check if assets use `Buffer`.
            const bufferAssets = Object.entries(assets).filter(([name])=>name.endsWith('.js')).filter(([, asset])=>asset.source().includes('Buffer'));
            if (bufferAssets.length === 0) {
                return;
            }
            warn(`The snap attempted to use the Node.js Buffer global, which is not supported in the MetaMask Snaps CLI by default.\n` + `To use the Buffer global, you must polyfill Buffer by setting ${yellow(`buffer`)} to ${yellow(`true`)} in the ${yellow(`polyfills`)} config object in your snap config.\n` + `To disable this warning, set ${yellow('`stats.buffer`')} to ${yellow('`false`')} in your snap config file.`, _class_private_field_get(this, _spinner3));
        });
    });
}

//# sourceMappingURL=plugins.js.map