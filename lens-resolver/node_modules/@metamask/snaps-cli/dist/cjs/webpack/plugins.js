"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SnapsStatsPlugin: function() {
        return SnapsStatsPlugin;
    },
    SnapsWatchPlugin: function() {
        return SnapsWatchPlugin;
    },
    SnapsBuiltInResolver: function() {
        return SnapsBuiltInResolver;
    },
    SnapsBundleWarningsPlugin: function() {
        return SnapsBundleWarningsPlugin;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _chalk = require("chalk");
const _module = require("module");
const _eval = require("../commands/eval");
const _utils1 = require("../utils");
const _utils2 = require("./utils");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var _spinner = /*#__PURE__*/ new WeakMap(), /**
   * Get the error message for the given stats error.
   *
   * @param statsError - The stats error.
   * @returns The error message.
   */ _getStatsErrorMessage = /*#__PURE__*/ new WeakSet();
class SnapsStatsPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        compiler.hooks.afterDone.tap(this.constructor.name, (stats)=>{
            if (!stats) {
                return;
            }
            const { modules, time, errors } = stats.toJson();
            (0, _utils.assert)(modules, 'Modules must be defined in stats.');
            (0, _utils.assert)(time, 'Time must be defined in stats.');
            if (errors?.length) {
                const formattedErrors = errors.map(_class_private_method_get(this, _getStatsErrorMessage, getStatsErrorMessage).bind(this)).join('\n\n');
                (0, _utils1.error)(`Compiled ${modules.length} ${(0, _utils2.pluralize)(modules.length, 'file')} in ${time}ms with ${errors.length} ${(0, _utils2.pluralize)(errors.length, 'error')}.\n\n${formattedErrors}\n`, _class_private_field_get(this, _spinner));
                _class_private_field_get(this, _spinner)?.stop();
                process.exitCode = 1;
                return;
            }
            (0, _utils1.info)(`Compiled ${modules.length} ${(0, _utils2.pluralize)(modules.length, 'file')} in ${time}ms.`, _class_private_field_get(this, _spinner));
            if (compiler.watchMode) {
                // The spinner may be restarted by the watch plugin, outside of the
                // `executeSteps` flow, so we stop it here just in case.
                _class_private_field_get(this, _spinner)?.succeed('Done!');
            }
        });
    }
    constructor(options = {
        verbose: false
    }, spinner){
        _class_private_method_init(this, _getStatsErrorMessage);
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner, spinner);
    }
}
function getStatsErrorMessage(statsError) {
    const baseMessage = this.options.verbose ? (0, _utils1.getErrorMessage)(statsError) : statsError.message;
    const [first, ...rest] = baseMessage.split('\n');
    return [
        (0, _snapsutils.indent)((0, _chalk.red)(`• ${first}`), 2),
        ...rest.map((message)=>(0, _snapsutils.indent)((0, _chalk.red)(message), 4)),
        statsError.details && (0, _snapsutils.indent)((0, _chalk.dim)(statsError.details), 4)
    ].filter(Boolean).join('\n');
}
var _spinner1 = /*#__PURE__*/ new WeakMap(), _safeEvaluate = /*#__PURE__*/ new WeakSet();
class SnapsWatchPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        compiler.hooks.invalid.tap(this.constructor.name, (file)=>{
            _class_private_field_get(this, _spinner1)?.start();
            (0, _utils1.info)(`Changes detected in ${(0, _chalk.yellow)(file)}, recompiling.`, _class_private_field_get(this, _spinner1));
        });
        compiler.hooks.afterEmit.tapPromise(this.constructor.name, async ({ fileDependencies })=>{
            this.options.files?.forEach(fileDependencies.add.bind(fileDependencies));
            if (this.options.bundle && this.options.evaluate) {
                await _class_private_method_get(this, _safeEvaluate, safeEvaluate).call(this, this.options.bundle);
            }
        });
    }
    constructor(options, spinner){
        /**
   * Safely evaluate the bundle at the given path. If an error occurs, it will
   * be logged to the console, rather than throwing an error.
   *
   * This function should never throw an error.
   *
   * @param bundlePath - The path to the bundle.
   */ _class_private_method_init(this, _safeEvaluate);
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner1, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner1, spinner);
    }
}
async function safeEvaluate(bundlePath) {
    try {
        await (0, _eval.evaluate)(bundlePath);
        (0, _utils1.info)(`Snap bundle evaluated successfully.`, _class_private_field_get(this, _spinner1));
    } catch (evaluateError) {
        (0, _utils1.error)(evaluateError.message, _class_private_field_get(this, _spinner1));
    }
}
var _source = /*#__PURE__*/ new WeakMap(), _spinner2 = /*#__PURE__*/ new WeakMap();
class SnapsBuiltInResolver {
    /**
   * Apply the plugin to the Webpack resolver.
   *
   * @param resolver - The Webpack resolver.
   */ apply(resolver) {
        resolver.getHook(_class_private_field_get(this, _source)).tapAsync(this.constructor.name, ({ module: isModule, request }, _, callback)=>{
            if (!isModule || !request) {
                return callback();
            }
            const baseRequest = request.split('/')[0];
            if ((0, _module.isBuiltin)(baseRequest) && !this.options.ignore?.includes(baseRequest)) {
                const fallback = resolver.options.fallback.find(({ name })=>name === baseRequest);
                if (fallback && !fallback.alias) {
                    this.unresolvedModules.add(baseRequest);
                }
            }
            return callback();
        });
    }
    constructor(options = {
        ignore: []
    }, spinner){
        /**
   * The built-in modules that have been imported, but not resolved.
   */ _define_property(this, "unresolvedModules", new Set());
        /**
   * The name of the resolver hook to tap into.
   */ _class_private_field_init(this, _source, {
            writable: true,
            value: 'described-resolve'
        });
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner2, {
            writable: true,
            value: void 0
        });
        this.options = options;
        _class_private_field_set(this, _spinner2, spinner);
    }
}
var _spinner3 = /*#__PURE__*/ new WeakMap(), /**
   * Check if a built-in module is used, but not provided by Webpack's
   * `fallback` configuration.
   *
   * @param compiler - The Webpack compiler.
   */ _checkBuiltIns = /*#__PURE__*/ new WeakSet(), /**
   * Check if the given instance is a `ProvidePlugin`. This is not guaranteed to
   * be accurate, but it's good enough for our purposes. If we were to use
   * `instanceof` instead, it might not work if multiple versions of Webpack are
   * installed.
   *
   * @param instance - The instance to check.
   * @returns Whether the instance is a `ProvidePlugin`, i.e., whether it's an
   * object with the name `ProvidePlugin` and a `definitions` property.
   */ _isProvidePlugin = /*#__PURE__*/ new WeakSet(), /**
   * Check if the `Buffer` global is used, but not provided by Webpack's
   * `DefinePlugin`.
   *
   * @param compiler - The Webpack compiler.
   */ _checkBuffer = /*#__PURE__*/ new WeakSet();
class SnapsBundleWarningsPlugin {
    /**
   * Apply the plugin to the Webpack compiler.
   *
   * @param compiler - The Webpack compiler.
   */ apply(compiler) {
        if (this.options.builtIns) {
            _class_private_method_get(this, _checkBuiltIns, checkBuiltIns).call(this, compiler);
        }
        if (this.options.buffer) {
            _class_private_method_get(this, _checkBuffer, checkBuffer).call(this, compiler);
        }
    }
    constructor(options = {
        buffer: true,
        builtIns: true
    }, spinner){
        _class_private_method_init(this, _checkBuiltIns);
        _class_private_method_init(this, _isProvidePlugin);
        _class_private_method_init(this, _checkBuffer);
        /**
   * The spinner to use for logging.
   */ _class_private_field_init(this, _spinner3, {
            writable: true,
            value: void 0
        });
        /**
   * The options for the plugin.
   */ _define_property(this, "options", void 0);
        this.options = options;
        _class_private_field_set(this, _spinner3, spinner);
    }
}
function checkBuiltIns(compiler) {
    compiler.hooks.afterCompile.tap(this.constructor.name, ()=>{
        if (!this.options.builtInResolver) {
            return;
        }
        const { unresolvedModules } = this.options.builtInResolver;
        if (unresolvedModules.size === 0) {
            return;
        }
        const formattedModules = new Array(...unresolvedModules).map((name)=>(0, _snapsutils.indent)(`• ${name}`, 2)).join('\n');
        (0, _utils1.warn)(`The snap attempted to use one or more Node.js builtins, but no browser fallback has been provided.\n` + `The MetaMask Snaps CLI does not support Node.js builtins by default. If you want to use this module, you must set ${(0, _chalk.yellow)(`polyfills`)} to ${(0, _chalk.yellow)(`true`)} or an object with the builtins to polyfill as the key and ${(0, _chalk.yellow)(`true`)} as the value.\n` + `To disable this warning, set ${(0, _chalk.yellow)('`stats.builtIns`')} to ${(0, _chalk.yellow)('`false`')} in your snap config file, or add the module to the ${(0, _chalk.yellow)('`stats.builtIns.ignore`')} array.\n\n${formattedModules}\n`, _class_private_field_get(this, _spinner3));
    });
}
function isProvidePlugin(instance) {
    return (0, _utils.isObject)(instance) && instance.constructor.name === 'ProvidePlugin' && (0, _utils.hasProperty)(instance, 'definitions');
}
function checkBuffer(compiler) {
    const plugin = compiler.options.plugins?.find((instance)=>_class_private_method_get(this, _isProvidePlugin, isProvidePlugin).call(this, instance));
    // If the `ProvidePlugin` is configured to provide `Buffer`, then we don't
    // need to warn the user.
    if (plugin) {
        const { definitions } = plugin;
        if (definitions.Buffer) {
            return;
        }
    }
    compiler.hooks.compilation.tap(this.constructor.name, (compilation)=>{
        compilation.hooks.afterProcessAssets.tap(this.constructor.name, (assets)=>{
            // Check if assets use `Buffer`.
            const bufferAssets = Object.entries(assets).filter(([name])=>name.endsWith('.js')).filter(([, asset])=>asset.source().includes('Buffer'));
            if (bufferAssets.length === 0) {
                return;
            }
            (0, _utils1.warn)(`The snap attempted to use the Node.js Buffer global, which is not supported in the MetaMask Snaps CLI by default.\n` + `To use the Buffer global, you must polyfill Buffer by setting ${(0, _chalk.yellow)(`buffer`)} to ${(0, _chalk.yellow)(`true`)} in the ${(0, _chalk.yellow)(`polyfills`)} config object in your snap config.\n` + `To disable this warning, set ${(0, _chalk.yellow)('`stats.buffer`')} to ${(0, _chalk.yellow)('`false`')} in your snap config file.`, _class_private_field_get(this, _spinner3));
        });
    });
}

//# sourceMappingURL=plugins.js.map