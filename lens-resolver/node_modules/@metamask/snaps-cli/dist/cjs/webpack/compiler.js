"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCompiler: function() {
        return getCompiler;
    },
    getServer: function() {
        return getServer;
    }
});
const _http = require("http");
const _servehandler = /*#__PURE__*/ _interop_require_default(require("serve-handler"));
const _webpack = require("webpack");
const _config = require("./config");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function getCompiler(config, options) {
    const baseWebpackConfig = await (0, _config.getDefaultConfiguration)(config, options);
    const webpackConfig = config.customizeWebpackConfig?.(baseWebpackConfig) ?? baseWebpackConfig;
    return (0, _webpack.webpack)(webpackConfig);
}
function getServer(config) {
    const server = (0, _http.createServer)((request, response)=>{
        (0, _servehandler.default)(request, response, {
            public: config.server.root,
            headers: [
                {
                    source: '**/*',
                    headers: [
                        {
                            key: 'Cache-Control',
                            value: 'no-cache'
                        },
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: '*'
                        }
                    ]
                }
            ]
        })?.catch(/* istanbul ignore next */ ()=>{
            response.statusCode = 500;
            response.end();
        });
    });
    /**
   * Start the server on the port specified in the config.
   *
   * @param port - The port to listen on.
   * @returns A promise that resolves when the server is listening. The promise
   * resolves to an object with the port and the server instance. Note that if
   * the `config.server.port` is `0`, the OS will choose a random port for us,
   * so we need to get the port from the server after it starts.
   */ const listen = async (port = config.server.port)=>{
        return new Promise((resolve, reject)=>{
            try {
                server.listen(port, ()=>{
                    const close = async ()=>{
                        await new Promise((resolveClose, rejectClose)=>{
                            server.close((closeError)=>{
                                if (closeError) {
                                    return rejectClose(closeError);
                                }
                                return resolveClose();
                            });
                        });
                    };
                    const address = server.address();
                    resolve({
                        port: address.port,
                        server,
                        close
                    });
                });
            } catch (listenError) {
                reject(listenError);
            }
        });
    };
    return {
        listen
    };
}

//# sourceMappingURL=compiler.js.map