"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BROWSERSLIST_FILE: function() {
        return BROWSERSLIST_FILE;
    },
    WEBPACK_FALLBACKS: function() {
        return WEBPACK_FALLBACKS;
    },
    getDefaultLoader: function() {
        return getDefaultLoader;
    },
    getDevTool: function() {
        return getDevTool;
    },
    getProgressHandler: function() {
        return getProgressHandler;
    },
    getBrowserslistTargets: function() {
        return getBrowserslistTargets;
    },
    pluralize: function() {
        return pluralize;
    },
    getFallbacks: function() {
        return getFallbacks;
    }
});
const _chalk = require("chalk");
const _fs = require("fs");
const _module = require("module");
const _path = require("path");
const BROWSERSLIST_FILE = (0, _path.resolve)((0, _path.dirname)(// eslint-disable-next-line n/no-extraneous-require
require.resolve('@metamask/snaps-cli/package.json')), '.browserslistrc');
const WEBPACK_FALLBACKS = {
    assert: require.resolve('assert/'),
    buffer: require.resolve('buffer/'),
    console: require.resolve('console-browserify'),
    constants: require.resolve('constants-browserify'),
    crypto: require.resolve('crypto-browserify'),
    domain: require.resolve('domain-browser'),
    events: require.resolve('events/'),
    http: require.resolve('stream-http'),
    https: require.resolve('https-browserify'),
    os: require.resolve('os-browserify/browser'),
    path: require.resolve('path-browserify'),
    punycode: require.resolve('punycode/'),
    process: require.resolve('process/browser'),
    querystring: require.resolve('querystring-es3'),
    stream: require.resolve('stream-browserify'),
    /* eslint-disable @typescript-eslint/naming-convention  */ _stream_duplex: require.resolve('readable-stream/lib/_stream_duplex'),
    _stream_passthrough: require.resolve('readable-stream/lib/_stream_passthrough'),
    _stream_readable: require.resolve('readable-stream/lib/_stream_readable'),
    _stream_transform: require.resolve('readable-stream/lib/_stream_transform'),
    _stream_writable: require.resolve('readable-stream/lib/_stream_writable'),
    string_decoder: require.resolve('string_decoder/'),
    /* eslint-enable @typescript-eslint/naming-convention  */ sys: require.resolve('util/'),
    timers: require.resolve('timers-browserify'),
    tty: require.resolve('tty-browserify'),
    url: require.resolve('url/'),
    util: require.resolve('util/'),
    vm: require.resolve('vm-browserify'),
    zlib: require.resolve('browserify-zlib')
};
async function getDefaultLoader({ legacy, sourceMap }) {
    if (legacy) {
        return {
            /**
       * If the snap uses the legacy config, we use the custom `browserify`
       * loader. This uses the legacy Browserify config to transpile the code.
       * This is necessary for backwards compatibility with the
       * `bundlerCustomizer` function.
       */ loader: (0, _path.resolve)(__dirname, 'loaders', 'browserify'),
            /**
       * The options for the `browserify` loader. These can be overridden in the
       * snap config.
       */ options: legacy
        };
    }
    const targets = await getBrowserslistTargets();
    return {
        /**
     * We use the `swc-loader` to transpile TypeScript and JavaScript files.
     * This is a Webpack loader that uses the `SWC` compiler, which is a much
     * faster alternative to Babel and TypeScript's own compiler.
     */ loader: 'swc-loader',
        /**
     * The options for the `swc-loader`. These can be overridden in the
     * `.swcrc` file.
     *
     * @see https://swc.rs/docs/configuration/swcrc
     */ options: {
            sync: false,
            /**
       * This tells SWC to generate source maps. We set it to the
       * `sourceMap` value from the config object.
       *
       * This must be enabled if source maps are enabled in the config.
       */ sourceMaps: Boolean(getDevTool(sourceMap)),
            jsc: {
                parser: {
                    /**
           * This tells the parser to parse TypeScript files. If you
           * don't need to support TypeScript, you can set this to
           * `ecmascript` instead, but there's no harm in leaving it
           * as `typescript`.
           *
           * @see https://swc.rs/docs/configuration/compilation#jscparser
           */ syntax: 'typescript'
                }
            },
            /**
       * The module configuration. This tells SWC how to output the
       * transpiled code.
       *
       * @see https://swc.rs/docs/configuration/modules
       */ module: {
                /**
         * This tells SWC to output CommonJS modules. MetaMask Snaps
         * doesn't support ES modules yet, so this is necessary.
         *
         * @see https://swc.rs/docs/configuration/modules#commonjs
         */ type: 'commonjs'
            },
            env: {
                targets: targets.join(', ')
            }
        }
    };
}
function getDevTool(sourceMap) {
    if (sourceMap === 'inline') {
        return 'inline-source-map';
    }
    if (sourceMap === true) {
        return 'source-map';
    }
    return false;
}
function getProgressHandler(spinner, spinnerText) {
    return (percentage)=>{
        if (spinner && spinnerText) {
            spinner.text = `${spinnerText} ${(0, _chalk.dim)(`(${Math.round(percentage * 100)}%)`)}`;
        }
    };
}
async function getBrowserslistTargets() {
    const contents = await _fs.promises.readFile(BROWSERSLIST_FILE, 'utf8');
    return contents.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.startsWith('#'));
}
function pluralize(count, singular, plural = `${singular}s`) {
    return count === 1 ? singular : plural;
}
function getFallbacks(polyfills) {
    if (polyfills === true) {
        return Object.fromEntries(_module.builtinModules.map((name)=>[
                name,
                WEBPACK_FALLBACKS[name] ?? false
            ]));
    }
    if (polyfills === false) {
        return Object.fromEntries(_module.builtinModules.map((name)=>[
                name,
                false
            ]));
    }
    return Object.fromEntries(_module.builtinModules.map((name)=>[
            name,
            polyfills[name] ? WEBPACK_FALLBACKS[name] : false
        ]));
}

//# sourceMappingURL=utils.js.map