"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "evaluateHandler", {
    enumerable: true,
    get: function() {
        return evaluateHandler;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _path = require("path");
const _errors = require("../../errors");
const _utils = require("../../utils");
const _implementation = require("./implementation");
const steps = [
    {
        name: 'Checking the input file.',
        task: async ({ input })=>{
            if (!await (0, _snapsutils.isFile)(input)) {
                const relativePath = (0, _utils.getRelativePath)(input);
                throw new _errors.CommandError(`Input file not found: "${relativePath}". Make sure that the "input" field in your snap config or the specified input file is correct.`);
            }
        }
    },
    {
        name: 'Evaluating the snap bundle.',
        task: async ({ input, spinner })=>{
            await (0, _implementation.evaluate)(input);
            spinner.succeed('Snap bundle evaluated successfully.');
        }
    }
];
/**
 * Returns the path to the bundle, based on the config and options.
 *
 * - If `options.input` is specified, it is used as the bundle path.
 * - Otherwise, the bundle path is resolved from the config's output path and
 * filename.
 *
 * @param config - The processed config object.
 * @param options - The eval options.
 * @returns The path to the bundle.
 */ function getBundlePath(config, options) {
    if (options.input) {
        return (0, _path.resolve)(process.cwd(), options.input);
    }
    return (0, _path.resolve)(config.output.path, config.output.filename);
}
async function evaluateHandler(config, options = {}) {
    const input = getBundlePath(config, options);
    await (0, _utils.executeSteps)(steps, {
        input
    });
}

//# sourceMappingURL=eval.js.map