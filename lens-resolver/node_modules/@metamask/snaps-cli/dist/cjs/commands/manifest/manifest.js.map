{"version":3,"sources":["../../../../src/commands/manifest/manifest.ts"],"sourcesContent":["import { isFile } from '@metamask/snaps-utils';\n\nimport type { ProcessedConfig } from '../../config';\nimport { CommandError } from '../../errors';\nimport type { Steps } from '../../utils';\nimport { executeSteps } from '../../utils';\nimport { manifest } from './implementation';\n\ntype ManifestOptions = {\n  fix?: boolean;\n};\n\ntype ManifestContext = {\n  input: string;\n  config: ProcessedConfig;\n  options: ManifestOptions;\n};\n\nconst steps: Steps<ManifestContext> = [\n  {\n    name: 'Checking the input file.',\n    task: async ({ input }) => {\n      if (!(await isFile(input))) {\n        throw new CommandError(\n          `Manifest file not found: \"${input}\". Make sure that the \\`snap.manifest.json\\` file exists.`,\n        );\n      }\n    },\n  },\n  {\n    name: 'Validating the snap manifest.',\n    task: async ({ input, config, options, spinner }) => {\n      const write = getWriteManifest(config, options);\n      const valid = await manifest(input, write, spinner);\n\n      if (valid) {\n        spinner.succeed('The snap manifest file is valid.');\n      }\n    },\n  },\n];\n\n/**\n * Get whether to write the manifest to disk.\n *\n * @param config - The config object.\n * @param options - The options object.\n * @returns Whether to write the manifest to disk.\n */\nfunction getWriteManifest(config: ProcessedConfig, options: ManifestOptions) {\n  if (typeof options.fix === 'boolean') {\n    return options.fix;\n  }\n\n  return config.legacy?.writeManifest ?? false;\n}\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param config - The config object.\n * @param options - The options object.\n */\nexport async function manifestHandler(\n  config: ProcessedConfig,\n  options: ManifestOptions,\n) {\n  await executeSteps(steps, {\n    input: config.manifest.path,\n    config,\n    options,\n  });\n}\n"],"names":["manifestHandler","steps","name","task","input","isFile","CommandError","config","options","spinner","write","getWriteManifest","valid","manifest","succeed","fix","legacy","writeManifest","executeSteps","path"],"mappings":";;;;+BAiEsBA;;;eAAAA;;;4BAjEC;wBAGM;uBAEA;gCACJ;AAYzB,MAAMC,QAAgC;IACpC;QACEC,MAAM;QACNC,MAAM,OAAO,EAAEC,KAAK,EAAE;YACpB,IAAI,CAAE,MAAMC,IAAAA,kBAAM,EAACD,QAAS;gBAC1B,MAAM,IAAIE,oBAAY,CACpB,CAAC,0BAA0B,EAAEF,MAAM,yDAAyD,CAAC;YAEjG;QACF;IACF;IACA;QACEF,MAAM;QACNC,MAAM,OAAO,EAAEC,KAAK,EAAEG,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAE;YAC9C,MAAMC,QAAQC,iBAAiBJ,QAAQC;YACvC,MAAMI,QAAQ,MAAMC,IAAAA,wBAAQ,EAACT,OAAOM,OAAOD;YAE3C,IAAIG,OAAO;gBACTH,QAAQK,OAAO,CAAC;YAClB;QACF;IACF;CACD;AAED;;;;;;CAMC,GACD,SAASH,iBAAiBJ,MAAuB,EAAEC,OAAwB;IACzE,IAAI,OAAOA,QAAQO,GAAG,KAAK,WAAW;QACpC,OAAOP,QAAQO,GAAG;IACpB;IAEA,OAAOR,OAAOS,MAAM,EAAEC,iBAAiB;AACzC;AAUO,eAAejB,gBACpBO,MAAuB,EACvBC,OAAwB;IAExB,MAAMU,IAAAA,mBAAY,EAACjB,OAAO;QACxBG,OAAOG,OAAOM,QAAQ,CAACM,IAAI;QAC3BZ;QACAC;IACF;AACF"}