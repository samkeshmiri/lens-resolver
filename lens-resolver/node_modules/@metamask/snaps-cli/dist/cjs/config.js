"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SnapsBrowserifyConfigStruct: function() {
        return SnapsBrowserifyConfigStruct;
    },
    SnapsWebpackConfigStruct: function() {
        return SnapsWebpackConfigStruct;
    },
    SnapsConfigStruct: function() {
        return SnapsConfigStruct;
    },
    LegacyOptionsStruct: function() {
        return LegacyOptionsStruct;
    },
    getConfig: function() {
        return getConfig;
    },
    loadConfig: function() {
        return loadConfig;
    },
    resolveConfig: function() {
        return resolveConfig;
    },
    getConfigByArgv: function() {
        return getConfigByArgv;
    },
    mergeLegacyOptions: function() {
        return mergeLegacyOptions;
    },
    getWebpackConfig: function() {
        return getWebpackConfig;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _core = require("@swc/core");
const _chalk = require("chalk");
const _promises = require("fs/promises");
const _module = /*#__PURE__*/ _interop_require_default(require("module"));
const _path = require("path");
const _superstruct = require("superstruct");
const _builders = require("./builders");
const _errors = require("./errors");
const _utils1 = require("./utils");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const CONFIG_FILES = [
    _utils1.CONFIG_FILE,
    _utils1.TS_CONFIG_FILE
];
// This struct is essentially the same as the `func` struct, but it's defined
// separately so that we include the function type in the inferred TypeScript
// type definitions.
const SnapsBrowserifyBundlerCustomizerFunctionStruct = (0, _superstruct.define)('function', (0, _superstruct.func)().validator);
const SnapsBrowserifyConfigStruct = (0, _superstruct.object)({
    bundler: (0, _superstruct.defaulted)((0, _snapsutils.literal)('browserify'), 'browserify'),
    cliOptions: (0, _superstruct.defaulted)((0, _superstruct.object)({
        bundle: (0, _superstruct.optional)((0, _snapsutils.file)()),
        dist: (0, _superstruct.defaulted)((0, _snapsutils.file)(), 'dist'),
        eval: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        manifest: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        port: (0, _superstruct.defaulted)((0, _superstruct.number)(), 8081),
        outfileName: (0, _superstruct.defaulted)((0, _superstruct.string)(), 'bundle.js'),
        root: (0, _superstruct.defaulted)((0, _snapsutils.file)(), process.cwd()),
        sourceMaps: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
        src: (0, _superstruct.defaulted)((0, _snapsutils.file)(), 'src/index.js'),
        stripComments: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        suppressWarnings: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
        transpilationMode: (0, _superstruct.defaulted)((0, _snapsutils.union)([
            (0, _snapsutils.literal)('localAndDeps'),
            (0, _snapsutils.literal)('localOnly'),
            (0, _snapsutils.literal)('none')
        ]), 'localOnly'),
        depsToTranspile: (0, _superstruct.defaulted)((0, _superstruct.array)((0, _superstruct.string)()), []),
        verboseErrors: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        writeManifest: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        serve: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true)
    }), {}),
    bundlerCustomizer: (0, _superstruct.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct)
});
// This struct is essentially the same as the `func` struct, but it's defined
// separately so that we include the function type in the inferred TypeScript
// type definitions.
const SnapsWebpackCustomizeWebpackConfigFunctionStruct = (0, _superstruct.define)('function', (0, _superstruct.func)().validator);
const SnapsWebpackConfigStruct = (0, _superstruct.object)({
    bundler: (0, _snapsutils.literal)('webpack'),
    input: (0, _superstruct.defaulted)((0, _snapsutils.file)(), (0, _path.resolve)(process.cwd(), 'src/index.js')),
    sourceMap: (0, _superstruct.defaulted)((0, _snapsutils.union)([
        (0, _superstruct.boolean)(),
        (0, _snapsutils.literal)('inline')
    ]), true),
    evaluate: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
    output: (0, _superstruct.defaulted)((0, _superstruct.object)({
        path: (0, _superstruct.defaulted)((0, _snapsutils.file)(), (0, _path.resolve)(process.cwd(), 'dist')),
        filename: (0, _superstruct.defaulted)((0, _superstruct.string)(), 'bundle.js'),
        clean: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
        minimize: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true)
    }), {}),
    manifest: (0, _superstruct.defaulted)((0, _superstruct.object)({
        path: (0, _superstruct.defaulted)((0, _snapsutils.file)(), (0, _path.resolve)(process.cwd(), 'snap.manifest.json')),
        update: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true)
    }), {}),
    server: (0, _superstruct.defaulted)((0, _superstruct.object)({
        enabled: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true),
        root: (0, _superstruct.defaulted)((0, _snapsutils.file)(), process.cwd()),
        port: (0, _superstruct.defaulted)((0, _superstruct.number)(), 8081)
    }), {}),
    environment: (0, _superstruct.defaulted)((0, _superstruct.record)((0, _superstruct.string)(), (0, _superstruct.unknown)()), {
        NODE_DEBUG: false,
        NODE_ENV: 'production',
        DEBUG: false
    }),
    stats: (0, _superstruct.defaulted)((0, _superstruct.object)({
        verbose: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
        builtIns: (0, _superstruct.defaulted)((0, _snapsutils.union)([
            (0, _superstruct.object)({
                ignore: (0, _superstruct.defaulted)((0, _superstruct.array)((0, _superstruct.string)()), [])
            }),
            (0, _snapsutils.literal)(false)
        ]), {}),
        buffer: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), true)
    }), {}),
    polyfills: (0, _superstruct.defaulted)((0, _snapsutils.union)([
        (0, _superstruct.boolean)(),
        (0, _superstruct.object)({
            assert: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            buffer: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            console: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            constants: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            crypto: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            domain: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            events: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            http: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            https: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            os: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            path: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            punycode: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            process: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            querystring: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            stream: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            /* eslint-disable @typescript-eslint/naming-convention */ _stream_duplex: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            _stream_passthrough: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            _stream_readable: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            _stream_transform: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            _stream_writable: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            string_decoder: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            /* eslint-enable @typescript-eslint/naming-convention */ sys: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            timers: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            tty: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            url: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            util: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            vm: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false),
            zlib: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false)
        })
    ]), false),
    customizeWebpackConfig: (0, _superstruct.optional)(SnapsWebpackCustomizeWebpackConfigFunctionStruct),
    experimental: (0, _superstruct.defaulted)((0, _superstruct.object)({
        wasm: (0, _superstruct.defaulted)((0, _superstruct.boolean)(), false)
    }), {})
});
const SnapsConfigStruct = (0, _superstruct.type)({
    bundler: (0, _superstruct.defaulted)((0, _snapsutils.union)([
        (0, _snapsutils.literal)('browserify'),
        (0, _snapsutils.literal)('webpack')
    ]), 'browserify')
});
const LegacyOptionsStruct = (0, _snapsutils.union)([
    (0, _snapsutils.named)('object with `transpilationMode` set to `localAndDeps` and `depsToTranspile` set to an array of strings', (0, _superstruct.type)({
        depsToTranspile: (0, _superstruct.array)((0, _superstruct.string)()),
        transpilationMode: (0, _snapsutils.literal)(_builders.TranspilationModes.LocalAndDeps),
        writeManifest: (0, _superstruct.boolean)(),
        bundlerCustomizer: (0, _superstruct.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct)
    })),
    (0, _snapsutils.named)('object without `depsToTranspile`', (0, _superstruct.type)({
        depsToTranspile: (0, _snapsutils.named)('empty array', (0, _superstruct.empty)((0, _superstruct.array)())),
        transpilationMode: (0, _snapsutils.union)([
            (0, _snapsutils.literal)(_builders.TranspilationModes.LocalOnly),
            (0, _snapsutils.literal)(_builders.TranspilationModes.None)
        ]),
        writeManifest: (0, _superstruct.boolean)(),
        bundlerCustomizer: (0, _superstruct.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct)
    }))
]);
function getConfig(config, argv) {
    const prefix = 'The snap config file is invalid';
    const suffix = (0, _chalk.dim)(// TODO: Link to `docs.metamask.io` once the docs are published.
    'Refer to the documentation for more information: https://github.com/MetaMask/snaps/tree/main/packages/snaps-cli/');
    const { bundler } = (0, _snapsutils.createFromStruct)(config, SnapsConfigStruct, prefix, suffix);
    if (bundler === 'browserify') {
        const legacyConfig = (0, _snapsutils.createFromStruct)(config, SnapsBrowserifyConfigStruct, prefix, suffix);
        return getWebpackConfig(mergeLegacyOptions(argv, legacyConfig));
    }
    return (0, _snapsutils.createFromStruct)(config, SnapsWebpackConfigStruct, prefix, suffix);
}
async function loadConfig(path, argv) {
    try {
        const contents = await (0, _promises.readFile)(path, 'utf8');
        const source = await (0, _core.transform)(contents, {
            swcrc: false,
            jsc: {
                parser: {
                    syntax: 'typescript'
                }
            },
            module: {
                type: 'commonjs'
            }
        });
        const config = new _module.default(path);
        // @ts-expect-error - This function is not typed.
        config.paths = _module.default._nodeModulePaths((0, _path.dirname)(path));
        // @ts-expect-error - This function is not typed.
        config._compile(source.code, path);
        if (!(0, _utils.hasProperty)(config.exports, 'default')) {
            return getConfig(config.exports, argv);
        }
        return getConfig(config.exports.default, argv);
    } catch (error) {
        if (error instanceof _snapsutils.SnapsStructError) {
            throw new _errors.ConfigError(error.message);
        }
        throw new _errors.ConfigError(`Unable to load snap config file at "${path}".\n\n${(0, _snapsutils.indent)(error.message)}`);
    }
}
async function resolveConfig(path, argv) {
    for (const configFile of CONFIG_FILES){
        const filePath = (0, _path.resolve)(path, configFile);
        if (await (0, _snapsutils.isFile)(filePath)) {
            return await loadConfig(filePath, argv);
        }
    }
    throw new _errors.ConfigError(`Could not find a "snap.config.js" or "snap.config.ts" file in the current or specified directory ("${path}").`);
}
async function getConfigByArgv(argv, cwd = process.cwd()) {
    if (argv.config) {
        if (!await (0, _snapsutils.isFile)(argv.config)) {
            throw new _errors.ConfigError(`Could not find a config file at "${argv.config}". Make sure that the path is correct.`);
        }
        return await loadConfig(argv.config, argv);
    }
    return await resolveConfig(cwd, argv);
}
function mergeLegacyOptions(argv, config) {
    const cliOptions = Object.keys(config.cliOptions).reduce((accumulator, key)=>{
        if (argv[key] !== undefined) {
            return {
                ...accumulator,
                [key]: argv[key]
            };
        }
        return accumulator;
    }, config.cliOptions);
    return {
        ...config,
        cliOptions
    };
}
function getWebpackConfig(legacyConfig) {
    const defaultConfig = (0, _superstruct.create)({
        bundler: 'webpack'
    }, SnapsWebpackConfigStruct);
    // The legacy config has two options for specifying the output path and
    // filename: `bundle`, and `dist` + `outfileName`. If `bundle` is specified,
    // we use that as the output path and filename. Otherwise, we use `dist` and
    // `outfileName`.
    const path = legacyConfig.cliOptions.bundle ? (0, _path.dirname)(legacyConfig.cliOptions.bundle) : legacyConfig.cliOptions.dist;
    const filename = legacyConfig.cliOptions.bundle ? (0, _path.basename)(legacyConfig.cliOptions.bundle) : legacyConfig.cliOptions.outfileName;
    return {
        ...defaultConfig,
        input: legacyConfig.cliOptions.src,
        evaluate: legacyConfig.cliOptions.eval,
        sourceMap: legacyConfig.cliOptions.sourceMaps,
        output: {
            path,
            filename,
            // The legacy config has an option to remove comments from the bundle, but
            // the terser plugin does this by default, so we only enable the terser if
            // the legacy config has `stripComments` set to `true`. This is not a
            // perfect solution, but it's the best we can do without breaking the
            // legacy config.
            minimize: legacyConfig.cliOptions.stripComments,
            // The legacy config does not have a `clean` option, so we default to
            // `false` here.
            clean: false
        },
        manifest: {
            // The legacy config does not have a `manifest` option, so we default to
            // `process.cwd()/snap.manifest.json`.
            path: (0, _path.resolve)(process.cwd(), 'snap.manifest.json'),
            update: legacyConfig.cliOptions.writeManifest
        },
        server: {
            enabled: legacyConfig.cliOptions.serve,
            port: legacyConfig.cliOptions.port,
            root: legacyConfig.cliOptions.root
        },
        stats: {
            verbose: false,
            // These plugins are designed to be used with the modern config format, so
            // we disable them for the legacy config format.
            builtIns: false,
            buffer: false
        },
        legacy: (0, _snapsutils.createFromStruct)({
            ...legacyConfig.cliOptions,
            bundlerCustomizer: legacyConfig.bundlerCustomizer
        }, LegacyOptionsStruct, 'Invalid Browserify CLI options')
    };
}

//# sourceMappingURL=config.js.map