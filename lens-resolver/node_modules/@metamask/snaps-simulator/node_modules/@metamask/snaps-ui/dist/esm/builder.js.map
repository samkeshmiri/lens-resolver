{"version":3,"sources":["../../src/builder.ts"],"sourcesContent":["import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from 'superstruct';\n\nimport type { Component } from './nodes';\nimport {\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  NodeType,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n} from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * ```typescript\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * ```\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n */\nfunction createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.text - The text to copy.\n * @returns A {@link Copyable} component.\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n]);\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @example\n * ```typescript\n * const node = divider();\n * ```\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.text - The heading text.\n * @returns The heading node as object.\n * @example\n * ```typescript\n * const node = heading({ text: 'Hello, world!' });\n * const node = heading('Hello, world!');\n * ```\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @example\n * ```typescript\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n * ```\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @example\n * ```typescript\n * const node = spinner();\n * ```\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable/disable markdown.\n * @returns The text node as object.\n * @example\n * ```typescript\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n * ```\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n"],"names":["assertStruct","isPlainObject","CopyableStruct","DividerStruct","HeadingStruct","NodeType","PanelStruct","SpinnerStruct","TextStruct","createBuilder","type","struct","keys","args","length","node","reduce","partialNode","key","index","undefined","copyable","Copyable","divider","Divider","heading","Heading","panel","Panel","spinner","Spinner","text","Text"],"mappings":"AAAA,SAASA,YAAY,EAAEC,aAAa,QAAQ,kBAAkB;AAI9D,SACEC,cAAc,EACdC,aAAa,EACbC,aAAa,EACbC,QAAQ,EACRC,WAAW,EACXC,aAAa,EACbC,UAAU,QACL,UAAU;AA4BjB;;;;;;;;;;;;;;;CAeC,GACD,SAASC,cAIPC,IAAc,EACdC,MAAoB,EACpBC,OAAa,EAAE,AAAmB;IAElC,OAAO,CAAC,GAAGC;QACT,kCAAkC;QAClC,IAAIA,KAAKC,MAAM,KAAK,KAAKb,cAAcY,IAAI,CAAC,EAAE,GAAG;YAC/C,MAAME,OAAO;gBAAE,GAAGF,IAAI,CAAC,EAAE;gBAAEH;YAAK;YAEhC,yEAAyE;YACzE,+CAA+C;YAC/CV,aAAae,MAAMJ,QAAQ,CAAC,QAAQ,EAAED,KAAK,UAAU,CAAC;YACtD,OAAOK;QACT;QAEA,wCAAwC;QACxC,MAAMA,OAAOH,KAAKI,MAAM,CACtB,CAACC,aAAaC,KAAKC;YACjB,IAAIN,IAAI,CAACM,MAAM,KAAKC,WAAW;gBAC7B,OAAO;oBACL,GAAGH,WAAW;oBACd,CAACC,IAAI,EAAEL,IAAI,CAACM,MAAM;gBACpB;YACF;YAEA,OAAOF;QACT,GACA;YAAEP;QAAK;QAGT,yEAAyE;QACzE,+CAA+C;QAC/CV,aAAae,MAAMJ,QAAQ,CAAC,QAAQ,EAAED,KAAK,UAAU,CAAC;QACtD,OAAOK;IACT;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,MAAMM,WAAWZ,cAAcJ,SAASiB,QAAQ,EAAEpB,gBAAgB;IACvE;CACD,EAAE;AAEH;;;;;;;;CAQC,GACD,OAAO,MAAMqB,UAAUd,cAAcJ,SAASmB,OAAO,EAAErB,eAAe;AAEtE;;;;;;;;;;;;CAYC,GACD,OAAO,MAAMsB,UAAUhB,cAAcJ,SAASqB,OAAO,EAAEtB,eAAe;IACpE;CACD,EAAE;AAEH;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,OAAO,MAAMuB,QAAQlB,cAAcJ,SAASuB,KAAK,EAAEtB,aAAa;IAAC;CAAW,EAAE;AAE9E;;;;;;;;CAQC,GACD,OAAO,MAAMuB,UAAUpB,cAAcJ,SAASyB,OAAO,EAAEvB,eAAe;AAEtE;;;;;;;;;;;;;;;;CAgBC,GACD,OAAO,MAAMwB,OAAOtB,cAAcJ,SAAS2B,IAAI,EAAExB,YAAY;IAC3D;IACA;CACD,EAAE"}