function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import { nanoid } from "@reduxjs/toolkit";
import { call, put, select, take } from "redux-saga/effects";
import { addNativeNotification, addNotification } from "../notifications";
import { closeUserInterface, getRequestId, getSnapName, getSnapStateSelector, resolveUserInterface, setSnapState, showUserInterface } from "./slice";
/**
 * Show a dialog to the user.
 *
 * @param snapId - The ID of the Snap that created the alert.
 * @param type - The type of dialog to show.
 * @param content - The content to show in the dialog.
 * @param _placeholder - The placeholder text to show in the dialog.
 * @yields Selects the current state.
 * @returns True if the dialog was shown, false otherwise.
 */ export function showDialog(snapId, type, content, _placeholder) {
    var snapName, payload;
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                return [
                    4,
                    select(getSnapName)
                ];
            case 1:
                snapName = _state.sent();
                // TODO: Support placeholder.
                return [
                    4,
                    put(showUserInterface({
                        snapId: snapId,
                        snapName: snapName !== null && snapName !== void 0 ? snapName : snapId,
                        type: type,
                        node: content
                    }))
                ];
            case 2:
                _state.sent();
                return [
                    4,
                    take(resolveUserInterface.type)
                ];
            case 3:
                payload = _state.sent().payload;
                return [
                    4,
                    put(closeUserInterface())
                ];
            case 4:
                _state.sent();
                return [
                    2,
                    payload
                ];
        }
    });
}
/**
 * Show a native notification to the user.
 *
 * @param _snapId - The ID of the Snap that created the alert.
 * @param args - The arguments to pass to the notification.
 * @param args.message - The message to show in the notification.
 * @yields Calls the Notification API.
 * @returns `null`.
 */ export function showNativeNotification(_snapId, param) {
    var message, id, snapName, permission;
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                message = param.message;
                return [
                    4,
                    select(getRequestId)
                ];
            case 1:
                id = _state.sent();
                return [
                    4,
                    put(addNativeNotification({
                        id: id,
                        message: message
                    }))
                ];
            case 2:
                _state.sent();
                return [
                    4,
                    select(getSnapName)
                ];
            case 3:
                snapName = _state.sent();
                if (!(Notification.permission === "default")) return [
                    3,
                    6
                ];
                return [
                    4,
                    call([
                        Notification,
                        "requestPermission"
                    ])
                ];
            case 4:
                permission = _state.sent();
                if (!(permission === "denied")) return [
                    3,
                    6
                ];
                // Show notification permission denied error.
                return [
                    4,
                    put(addNotification({
                        id: nanoid(),
                        message: "Unable to show browser notification. Make sure notifications are enabled in your browser settings."
                    }))
                ];
            case 5:
                _state.sent();
                _state.label = 6;
            case 6:
                if (!(Notification.permission === "denied")) return [
                    3,
                    8
                ];
                // Show notification permission denied error.
                return [
                    4,
                    put(addNotification({
                        id: nanoid(),
                        message: "Unable to show browser notification. Make sure notifications are enabled in your browser settings."
                    }))
                ];
            case 7:
                _state.sent();
                _state.label = 8;
            case 8:
                // eslint-disable-next-line no-new
                new Notification(snapName, {
                    body: message
                });
                return [
                    2,
                    null
                ];
        }
    });
}
/**
 * Show an in-app notification to the user.
 *
 * @param _snapId - The ID of the Snap that created the alert.
 * @param args - The arguments to pass to the notification.
 * @param args.message - The message to show in the notification.
 * @yields Adds a notification to the notification list.
 * @returns `null`.
 */ export function showInAppNotification(_snapId, param) {
    var message, id;
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                message = param.message;
                return [
                    4,
                    select(getRequestId)
                ];
            case 1:
                id = _state.sent();
                return [
                    4,
                    put(addNotification({
                        id: id,
                        message: message
                    }))
                ];
            case 2:
                _state.sent();
                return [
                    2,
                    null
                ];
        }
    });
}
/**
 * Updates the snap state in the simulation slice.
 *
 * @param _snapId - The snap id, unused for now.
 * @param newSnapState - The new state.
 * @yields Puts the newSnapState
 */ export function updateSnapState(_snapId, newSnapState) {
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                return [
                    4,
                    put(setSnapState(newSnapState))
                ];
            case 1:
                _state.sent();
                return [
                    2
                ];
        }
    });
}
/**
 * Gets the snap state from the simulation slice.
 *
 * @param _snapId - The snap id, unused for now.
 * @returns The snap state.
 * @yields Selects the snap state from the simulation slice.
 */ export function getSnapState(_snapId) {
    var state;
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                return [
                    4,
                    select(getSnapStateSelector)
                ];
            case 1:
                state = _state.sent();
                return [
                    2,
                    state
                ];
        }
    });
}
