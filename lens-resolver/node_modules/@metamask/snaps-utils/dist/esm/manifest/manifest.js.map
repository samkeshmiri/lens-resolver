{"version":3,"sources":["../../../src/manifest/manifest.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames, SnapValidationFailureReason } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file';\nimport type { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialPermissions: 7,\n  manifestVersion: 8,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @param writeFileFn - The function to use to write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n  writeFileFn: WriteFileFunction = fs.writeFile,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          validateNpmSnapManifest({ ...partiallyValidatedFiles, manifest });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): VirtualFile<SnapManifest> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap bundle file: ${error.message}`);\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${error.message}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an npm Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n */\nexport function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  validateSnapShasum(\n    { manifest, sourceCode, svgIcon },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n"],"names":["assertExhaustive","assert","isPlainObject","deepEqual","promises","fs","pathUtils","deepClone","readJsonFile","validateNpmSnap","getSnapChecksum","ProgrammaticallyFixableSnapError","validateSnapShasum","NpmSnapFileNames","SnapValidationFailureReason","readVirtualFile","VirtualFile","MANIFEST_SORT_ORDER","$schema","version","description","proposedName","repository","source","initialPermissions","manifestVersion","checkManifest","basePath","writeManifest","sourceCode","writeFileFn","writeFile","warnings","errors","updated","manifestPath","join","Manifest","manifestFile","unvalidatedManifest","result","packageFile","PackageJson","snapFiles","manifest","packageJson","getSnapSourceCode","svgIcon","getSnapIcon","error","push","message","partiallyValidatedFiles","isInvalid","currentError","maxAttempts","Object","keys","length","attempts","fixManifest","validateNpmSnapManifest","nextValidationError","Error","validatedManifest","recommendedFields","missingRecommendedFields","filter","key","reduce","allMissing","currentField","newManifest","JSON","stringify","getWritableManifest","value","clonedFile","clone","manifestCopy","reason","NameMismatch","location","npm","packageName","name","VersionMismatch","RepositoryMismatch","undefined","ShasumMismatch","shasum","sourceFilePath","filePath","path","virtualFile","iconPath","remaining","writableManifest","sort","a","b","packageJsonName","packageJsonVersion","packageJsonRepository","manifestPackageName","manifestPackageVersion","manifestRepository"],"mappings":"AACA,SAASA,gBAAgB,EAAEC,MAAM,EAAEC,aAAa,QAAQ,kBAAkB;AAC1E,OAAOC,eAAe,kBAAkB;AACxC,SAASC,YAAYC,EAAE,QAAQ,KAAK;AACpC,OAAOC,eAAe,OAAO;AAE7B,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,YAAY,QAAQ,QAAQ;AACrC,SAASC,eAAe,QAAQ,SAAS;AACzC,SACEC,eAAe,EACfC,gCAAgC,EAChCC,kBAAkB,QACb,WAAW;AAElB,SAASC,gBAAgB,EAAEC,2BAA2B,QAAQ,WAAW;AACzE,SAASC,eAAe,EAAEC,WAAW,QAAQ,kBAAkB;AAG/D,MAAMC,sBAA0D;IAC9DC,SAAS;IACTC,SAAS;IACTC,aAAa;IACbC,cAAc;IACdC,YAAY;IACZC,QAAQ;IACRC,oBAAoB;IACpBC,iBAAiB;AACnB;AAyBA;;;;;;;;;;;CAWC,GACD,OAAO,eAAeC,cACpBC,QAAgB,EAChBC,gBAAgB,IAAI,EACpBC,UAAmB,EACnBC,cAAiCzB,GAAG0B,SAAS;IAE7C,MAAMC,WAAqB,EAAE;IAC7B,MAAMC,SAAmB,EAAE;IAE3B,IAAIC,UAAU;IAEd,MAAMC,eAAe7B,UAAU8B,IAAI,CAACT,UAAUd,iBAAiBwB,QAAQ;IACvE,MAAMC,eAAe,MAAM9B,aAAa2B;IACxC,MAAMI,sBAAsBD,aAAaE,MAAM;IAE/C,MAAMC,cAAc,MAAMjC,aACxBF,UAAU8B,IAAI,CAACT,UAAUd,iBAAiB6B,WAAW;IAGvD,MAAMC,YAAkC;QACtCC,UAAUN;QACVO,aAAaJ;QACbZ,YAAY,MAAMiB,kBAChBnB,UACAY,qBACAV;QAEFkB,SAAS,MAAMC,YAAYrB,UAAUY;IACvC;IAEA,IAAIK;IACJ,IAAI;QACD,CAAA,EAAEA,QAAQ,EAAE,GAAGnC,gBAAgBkC,UAAS;IAC3C,EAAE,OAAOM,OAAO;QACd,IAAIA,iBAAiBtC,kCAAkC;YACrDsB,OAAOiB,IAAI,CAACD,MAAME,OAAO;YAEzB,6DAA6D;YAC7D,MAAMC,0BAA0BT;YAEhC,IAAIU,YAAY;YAChB,IAAIC,eAAeL;YACnB,MAAMM,cAAcC,OAAOC,IAAI,CAAC3C,6BAA6B4C,MAAM;YAEnE,0EAA0E;YAC1E,uEAAuE;YACvE,oEAAoE;YACpE,uBAAuB;YACvB,IAAK,IAAIC,WAAW,GAAGN,aAAaM,YAAYJ,aAAaI,WAAY;gBACvEf,WAAWgB,YACThB,WACI;oBAAE,GAAGQ,uBAAuB;oBAAER;gBAAS,IACvCQ,yBACJE;gBAGF,IAAI;oBACFO,wBAAwB;wBAAE,GAAGT,uBAAuB;wBAAER;oBAAS;oBAE/DS,YAAY;gBACd,EAAE,OAAOS,qBAAqB;oBAC5BR,eAAeQ;oBACf,mDAAmD,GACnD,IACE,CACEA,CAAAA,+BAA+BnD,gCAA+B,KAE/DgD,aAAaJ,eAAe,CAACF,WAC9B;wBACA,MAAM,IAAIU,MACR,CAAC,kFAAkF,EAAEd,MAAME,OAAO,CAAC,CAAC;oBAExG;oBAEAlB,OAAOiB,IAAI,CAACI,aAAaH,OAAO;gBAClC;YACF;YAEAjB,UAAU;QACZ,OAAO;YACL,MAAMe;QACR;IACF;IAEA,8EAA8E;IAC9E,0CAA0C;IAC1ChD,OAAO2C;IAEP,MAAMoB,oBAAoBpB,SAASJ,MAAM;IAEzC,qCAAqC;IACrC,MAAMyB,oBAAoB;QAAC;KAAa;IAExC,MAAMC,2BAA2BD,kBAAkBE,MAAM,CACvD,CAACC,MAAQ,CAACJ,iBAAiB,CAACI,IAAI;IAGlC,IAAIF,yBAAyBR,MAAM,GAAG,GAAG;QACvC1B,SAASkB,IAAI,CACX,CAAC,8CAA8C,EAAEgB,yBAAyBG,MAAM,CAC9E,CAACC,YAAYC;YACX,OAAO,CAAC,EAAED,WAAW,EAAE,EAAEC,aAAa,EAAE,CAAC;QAC3C,GACA,IACA,CAAC;IAEP;IAEA,IAAI3C,eAAe;QACjB,IAAI;YACF,MAAM4C,cAAc,CAAC,EAAEC,KAAKC,SAAS,CACnCC,oBAAoBX,oBACpB,MACA,GACA,EAAE,CAAC;YAEL,IAAI9B,WAAWsC,gBAAgBlC,aAAasC,KAAK,EAAE;gBACjD,MAAM9C,YACJxB,UAAU8B,IAAI,CAACT,UAAUd,iBAAiBwB,QAAQ,GAClDmC;YAEJ;QACF,EAAE,OAAOvB,OAAO;YACd,yEAAyE;YACzE,gCAAgC;YAChC,MAAM,IAAIc,MAAM,CAAC,qCAAqC,EAAEd,MAAME,OAAO,CAAC,CAAC;QACzE;IACF;IAEA,OAAO;QAAEP,UAAUoB;QAAmB9B;QAASF;QAAUC;IAAO;AAClE;AAEA;;;;;;;;CAQC,GACD,OAAO,SAAS2B,YACdjB,SAAoB,EACpBM,KAAuC;IAEvC,MAAM,EAAEL,QAAQ,EAAEC,WAAW,EAAE,GAAGF;IAClC,MAAMkC,aAAajC,SAASkC,KAAK;IACjC,MAAMC,eAAeF,WAAWrC,MAAM;IAEtC,OAAQS,MAAM+B,MAAM;QAClB,KAAKlE,4BAA4BmE,YAAY;YAC3CF,aAAaxD,MAAM,CAAC2D,QAAQ,CAACC,GAAG,CAACC,WAAW,GAAGvC,YAAYL,MAAM,CAAC6C,IAAI;YACtE;QAEF,KAAKvE,4BAA4BwE,eAAe;YAC9CP,aAAa5D,OAAO,GAAG0B,YAAYL,MAAM,CAACrB,OAAO;YACjD;QAEF,KAAKL,4BAA4ByE,kBAAkB;YACjDR,aAAazD,UAAU,GAAGuB,YAAYL,MAAM,CAAClB,UAAU,GACnDf,UAAUsC,YAAYL,MAAM,CAAClB,UAAU,IACvCkE;YACJ;QAEF,KAAK1E,4BAA4B2E,cAAc;YAC7CV,aAAaxD,MAAM,CAACmE,MAAM,GAAGhF,gBAAgBiC;YAC7C;QAEF,wBAAwB,GACxB;YACE3C,iBAAiBiD,MAAM+B,MAAM;IACjC;IAEAH,WAAWrC,MAAM,GAAGuC;IACpBF,WAAWD,KAAK,GAAGH,KAAKC,SAAS,CAACK;IAClC,OAAOF;AACT;AAEA;;;;;;;;CAQC,GACD,OAAO,eAAe/B,kBACpBnB,QAAgB,EAChBiB,QAAc,EACdf,UAAmB;IAEnB,IAAI,CAAC3B,cAAc0C,WAAW;QAC5B,OAAO4C;IACT;IAEA,MAAMG,iBAAiB,AAAC/C,SAAmCrB,MAAM,EAAE2D,UAC/DC,KAAKS;IAET,IAAI,CAACD,gBAAgB;QACnB,OAAOH;IACT;IAEA,IAAI3D,YAAY;QACd,OAAO,IAAIb,YAAY;YACrB6E,MAAMvF,UAAU8B,IAAI,CAACT,UAAUgE;YAC/Bf,OAAO/C;QACT;IACF;IAEA,IAAI;QACF,MAAMiE,cAAc,MAAM/E,gBACxBT,UAAU8B,IAAI,CAACT,UAAUgE,iBACzB;QAEF,OAAOG;IACT,EAAE,OAAO7C,OAAO;QACd,MAAM,IAAIc,MAAM,CAAC,iCAAiC,EAAEd,MAAME,OAAO,CAAC,CAAC;IACrE;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,eAAeH,YACpBrB,QAAgB,EAChBiB,QAAc;IAEd,IAAI,CAAC1C,cAAc0C,WAAW;QAC5B,OAAO4C;IACT;IAEA,MAAMO,WAAW,AAACnD,SAAmCrB,MAAM,EAAE2D,UAAUC,KACnEY;IAEJ,IAAI,CAACA,UAAU;QACb,OAAOP;IACT;IAEA,IAAI;QACF,MAAMM,cAAc,MAAM/E,gBACxBT,UAAU8B,IAAI,CAACT,UAAUoE,WACzB;QAEF,OAAOD;IACT,EAAE,OAAO7C,OAAO;QACd,MAAM,IAAIc,MAAM,CAAC,+BAA+B,EAAEd,MAAME,OAAO,CAAC,CAAC;IACnE;AACF;AAEA;;;;;;CAMC,GACD,OAAO,SAASwB,oBAAoB/B,QAAsB;IACxD,MAAM,EAAEtB,UAAU,EAAE,GAAG0E,WAAW,GAAGpD;IAErC,MAAMa,OAAOD,OAAOC,IAAI,CACtBnC,aAAa;QAAE,GAAG0E,SAAS;QAAE1E;IAAW,IAAI0E;IAG9C,MAAMC,mBAAmBxC,KACtByC,IAAI,CAAC,CAACC,GAAGC,IAAMnF,mBAAmB,CAACkF,EAAE,GAAGlF,mBAAmB,CAACmF,EAAE,EAC9D/B,MAAM,CACL,CAAC7B,QAAQ4B,MAAS,CAAA;YAChB,GAAG5B,MAAM;YACT,CAAC4B,IAAI,EAAExB,QAAQ,CAACwB,IAAI;QACtB,CAAA,GACA,CAAC;IAGL,OAAO6B;AACT;AAEA;;;;;;;;;CASC,GACD,OAAO,SAASpC,wBAAwB,EACtCjB,QAAQ,EACRC,WAAW,EACXhB,UAAU,EACVkB,OAAO,EACG;IACV,MAAMsD,kBAAkBxD,YAAYL,MAAM,CAAC6C,IAAI;IAC/C,MAAMiB,qBAAqBzD,YAAYL,MAAM,CAACrB,OAAO;IACrD,MAAMoF,wBAAwB1D,YAAYL,MAAM,CAAClB,UAAU;IAE3D,MAAMkF,sBAAsB5D,SAASJ,MAAM,CAACjB,MAAM,CAAC2D,QAAQ,CAACC,GAAG,CAACC,WAAW;IAC3E,MAAMqB,yBAAyB7D,SAASJ,MAAM,CAACrB,OAAO;IACtD,MAAMuF,qBAAqB9D,SAASJ,MAAM,CAAClB,UAAU;IAErD,IAAI+E,oBAAoBG,qBAAqB;QAC3C,MAAM,IAAI7F,iCACR,CAAC,CAAC,EAAEE,iBAAiBwB,QAAQ,CAAC,qBAAqB,EAAEmE,oBAAoB,uBAAuB,EAAE3F,iBAAiB6B,WAAW,CAAC,iBAAiB,EAAE2D,gBAAgB,GAAG,CAAC,EACtKvF,4BAA4BmE,YAAY;IAE5C;IAEA,IAAIqB,uBAAuBG,wBAAwB;QACjD,MAAM,IAAI9F,iCACR,CAAC,CAAC,EAAEE,iBAAiBwB,QAAQ,CAAC,wBAAwB,EAAEoE,uBAAuB,uBAAuB,EAAE5F,iBAAiB6B,WAAW,CAAC,oBAAoB,EAAE4D,mBAAmB,GAAG,CAAC,EAClLxF,4BAA4BwE,eAAe;IAE/C;IAEA,IAGE,AAFA,4EAA4E;IAC5E,wDAAwD;IACvDiB,CAAAA,yBAAyBG,kBAAiB,KAC3C,CAACvG,UAAUoG,uBAAuBG,qBAClC;QACA,MAAM,IAAI/F,iCACR,CAAC,CAAC,EAAEE,iBAAiBwB,QAAQ,CAAC,yCAAyC,EAAExB,iBAAiB6B,WAAW,CAAC,qBAAqB,CAAC,EAC5H5B,4BAA4ByE,kBAAkB;IAElD;IAEA3E,mBACE;QAAEgC;QAAUf;QAAYkB;IAAQ,GAChC,CAAC,CAAC,EAAElC,iBAAiBwB,QAAQ,CAAC,gDAAgD,CAAC;AAEnF"}