/* eslint-disable no-invalid-this */ // Note: Because this file imports from `@jest/globals`, it can only be used in
// a Jest environment. This is why it's not exported from the index file.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    toRespondWith: function() {
        return toRespondWith;
    },
    toRespondWithError: function() {
        return toRespondWithError;
    },
    toSendNotification: function() {
        return toSendNotification;
    },
    toRender: function() {
        return toRender;
    }
});
const _globals = require("@jest/globals");
const _utils = require("@metamask/utils");
const _jestmatcherutils = require("jest-matcher-utils");
const _superstruct = require("superstruct");
const _internals = require("./internals");
/**
 * Ensure that the actual value is a response from the `request` function.
 *
 * @param actual - The actual value.
 * @param matcherName - The name of the matcher.
 * @param options - The matcher options.
 */ function assertActualIsSnapResponse(actual, matcherName, options) {
    if (!(0, _superstruct.is)(actual, _internals.SnapResponseStruct)) {
        throw new Error((0, _jestmatcherutils.matcherErrorMessage)((0, _jestmatcherutils.matcherHint)(matcherName, undefined, undefined, options), `${(0, _jestmatcherutils.RECEIVED_COLOR)('received')} value must be a response from the \`request\` function`, (0, _jestmatcherutils.printWithType)('Received', actual, _jestmatcherutils.printReceived)));
    }
}
/**
 * Ensure that the actual value is a response from the `request` function, and
 * that it has a `ui` property.
 *
 * @param actual - The actual value.
 * @param matcherName - The name of the matcher.
 * @param options - The matcher options.
 */ function assertHasInterface(actual, matcherName, options) {
    if (!(0, _superstruct.is)(actual, _internals.InterfaceStruct) || !actual.content) {
        throw new Error((0, _jestmatcherutils.matcherErrorMessage)((0, _jestmatcherutils.matcherHint)(matcherName, undefined, undefined, options), `${(0, _jestmatcherutils.RECEIVED_COLOR)('received')} value must have a \`content\` property`, (0, _jestmatcherutils.printWithType)('Received', actual, _jestmatcherutils.printReceived)));
    }
}
const toRespondWith = function(actual, expected) {
    assertActualIsSnapResponse(actual, 'toRespondWith');
    const { response } = actual;
    if ((0, _utils.hasProperty)(response, 'error')) {
        const message = ()=>`${this.utils.matcherHint('.toRespondWith')}\n\n` + `Expected response: ${this.utils.printExpected(expected)}\n` + `Received error: ${this.utils.printReceived(response.error)}`;
        return {
            message,
            pass: false
        };
    }
    const pass = this.equals(response.result, expected);
    const message = pass ? ()=>`${this.utils.matcherHint('.not.toRespondWith')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(response.result)}` : ()=>`${this.utils.matcherHint('.toRespondWith')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(response.result)}`;
    return {
        message,
        pass
    };
};
const toRespondWithError = function(actual, expected) {
    assertActualIsSnapResponse(actual, 'toRespondWithError');
    const { response } = actual;
    if ((0, _utils.hasProperty)(response, 'result')) {
        const message = ()=>`${this.utils.matcherHint('.toRespondWithError')}\n\n` + `Expected error: ${this.utils.printExpected(expected)}\n` + `Received result: ${this.utils.printReceived(response.result)}`;
        return {
            message,
            pass: false
        };
    }
    const pass = this.equals(response.error, expected);
    const message = pass ? ()=>`${this.utils.matcherHint('.not.toRespondWithError')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(response.error)}` : ()=>`${this.utils.matcherHint('.toRespondWithError')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(response.error)}`;
    return {
        message,
        pass
    };
};
const toSendNotification = async function(actual, expected, type) {
    assertActualIsSnapResponse(actual, 'toSendNotification');
    const { notifications } = actual;
    const pass = notifications.some((notification)=>this.equals(notification.message, expected) && (type === undefined || notification.type === type));
    const message = pass ? ()=>`${this.utils.matcherHint('.not.toSendNotification')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Expected type: ${this.utils.printExpected(type)}\n` + `Received: ${this.utils.printReceived(notifications)}` : ()=>`${this.utils.matcherHint('.toSendNotification')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Expected type: ${this.utils.printExpected(type)}\n` + `Received: ${this.utils.printReceived(notifications)}`;
    return {
        message,
        pass
    };
};
const toRender = function(actual, expected) {
    assertHasInterface(actual, 'toRender');
    const { content } = actual;
    const pass = this.equals(content, expected);
    const difference = (0, _jestmatcherutils.diff)(expected, content);
    const message = pass ? ()=>`${this.utils.matcherHint('.not.toShowInterface')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(content)}` + `${difference ? `\n\nDifference:\n\n${difference}` : ''}` : ()=>`${this.utils.matcherHint('.toShowInterface')}\n\n` + `Expected: ${this.utils.printExpected(expected)}\n` + `Received: ${this.utils.printReceived(content)}` + `${difference ? `\n\nDifference:\n\n${difference}` : ''}`;
    return {
        message,
        pass
    };
};
_globals.expect.extend({
    toRespondWith,
    toRespondWithError,
    toSendNotification,
    toRender
});

//# sourceMappingURL=matchers.js.map