"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SnapsEnvironment: function() {
        return SnapsEnvironment;
    },
    default: function() {
        return _default;
    }
});
const _utils = require("@metamask/utils");
const _jestenvironmentnode = /*#__PURE__*/ _interop_require_default(require("jest-environment-node"));
const _webdriverio = require("webdriverio");
const _internals = require("./internals");
const _options = require("./options");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/* eslint-enable */ const log = (0, _utils.createModuleLogger)(_internals.rootLogger, 'environment');
var _options1 = /*#__PURE__*/ new WeakMap(), _server = /*#__PURE__*/ new WeakMap();
class SnapsEnvironment extends _jestenvironmentnode.default {
    /**
   * Set up the environment. This starts the built-in HTTP server, and creates a
   * new browser instance.
   */ async setup() {
        await super.setup();
        if (_class_private_field_get(this, _options1).server.enabled) {
            log('Starting server.');
            _class_private_field_set(this, _server, await (0, _internals.startServer)(_class_private_field_get(this, _options1).server));
        }
        const args = [];
        if (_class_private_field_get(this, _options1).browser.headless) {
            args.push('--headless', '--disable-gpu');
        }
        log('Starting browser.');
        this.browser = await (0, _webdriverio.remote)({
            logLevel: 'error',
            capabilities: {
                browserName: 'chrome',
                // eslint-disable-next-line @typescript-eslint/naming-convention
                'goog:chromeOptions': {
                    args
                }
            }
        });
        this.global.browser = this.browser;
        this.global.snapsEnvironment = this;
    }
    /**
   * Tear down the environment. This closes the browser, and stops the built-in
   * HTTP server.
   */ async teardown() {
        if (_class_private_field_get(this, _options1).keepAlive) {
            log('Not tearing down environment because keepAlive is enabled.');
            return;
        }
        log('Closing browser, and stopping server.');
        await this.browser?.deleteSession();
        _class_private_field_get(this, _server)?.close();
        await super.teardown();
    }
    /**
   * Get the URL to the simulator, including the environment URL.
   *
   * @returns The simulator URL.
   * @throws If the server is not running.
   */ get url() {
        (0, _utils.assert)(_class_private_field_get(this, _server), 'Server is not running.');
        const { port } = _class_private_field_get(this, _server).address();
        const simulatorUrl = _class_private_field_get(this, _options1).simulatorUrl ?? `http://localhost:${port}/simulator/`;
        const executionEnvironmentUrl = _class_private_field_get(this, _options1).executionEnvironmentUrl ?? `http://localhost:${port}/environment/`;
        return `${simulatorUrl}?environment=${encodeURIComponent(executionEnvironmentUrl)}`;
    }
    /**
   * Get the snap ID for the current environment, which is used if no snap ID is
   * passed to {@link installSnap}. This assumes that the built-in server is
   * running.
   *
   * @returns The snap ID.
   * @throws If the server is not running.
   */ get snapId() {
        (0, _utils.assert)(_class_private_field_get(this, _server), 'You must specify a snap ID, because the built-in server is not running.');
        const { port } = _class_private_field_get(this, _server).address();
        return `local:http://localhost:${port}`;
    }
    /**
   * Create a new page, and attach logging handlers.
   *
   * @param url - The page URL. Defaults to the specified Snaps Simulator URL,
   * or the default simulator URL if none is specified.
   * @param timeout - The page timeout, in milliseconds.
   * @returns The new page.
   */ async createPage(url = this.url, timeout = 10000) {
        const puppeteer = await this.browser.getPuppeteer();
        const page = await puppeteer.newPage();
        page.setDefaultTimeout(timeout);
        page.setDefaultNavigationTimeout(timeout);
        // Give the page permission to show notifications. This is required for
        // testing `snap_notify`.
        await page.browserContext().overridePermissions(url, [
            'notifications'
        ]);
        // `networkidle0` is used to ensure that the page is fully loaded. This
        // makes it wait for no requests to be made, which guarantees that the page
        // is ready.
        await page.goto(url, {
            waitUntil: 'networkidle0'
        });
        const browserLog = (0, _utils.createModuleLogger)(_internals.rootLogger, 'browser');
        page// This is fired when the page calls `console.log` or similar.
        .on('console', (message)=>{
            browserLog(`[${message.type()}] ${message.text()}`);
        })// This is fired when the page throws an error.
        .on('pageerror', ({ message })=>{
            browserLog(`[page error] ${message}`);
        });
        return page;
    }
    /**
   * Constructor.
   *
   * @param options - The environment options.
   * @param context - The environment context.
   */ constructor(options, context){
        super(options, context);
        // `browser` is always set in the environment setup function. To avoid needing
        // to check for `undefined` everywhere, we use a type assertion here.
        _define_property(this, "browser", void 0);
        _class_private_field_init(this, _options1, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _server, {
            writable: true,
            value: void 0
        });
        _class_private_field_set(this, _options1, (0, _options.getOptions)(options.projectConfig.testEnvironmentOptions));
    }
}
const _default = SnapsEnvironment;

//# sourceMappingURL=environment.js.map