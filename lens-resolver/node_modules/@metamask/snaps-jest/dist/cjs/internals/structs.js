"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    TransactionOptionsStruct: function() {
        return TransactionOptionsStruct;
    },
    SnapOptionsStruct: function() {
        return SnapOptionsStruct;
    },
    InterfaceStruct: function() {
        return InterfaceStruct;
    },
    SnapResponseStruct: function() {
        return SnapResponseStruct;
    }
});
const _rpcmethods = require("@metamask/rpc-methods");
const _snapsui = require("@metamask/snaps-ui");
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _crypto = require("crypto");
const _superstruct = require("superstruct");
// TODO: Export this from `@metamask/utils` instead.
const BytesLikeStruct = (0, _superstruct.union)([
    (0, _superstruct.bigint)(),
    (0, _superstruct.number)(),
    (0, _superstruct.string)(),
    (0, _superstruct.instance)(Uint8Array)
]);
const TransactionOptionsStruct = (0, _superstruct.object)({
    /**
   * The CAIP-2 chain ID to send the transaction on. Defaults to `eip155:1`.
   */ chainId: (0, _superstruct.defaulted)((0, _superstruct.string)(), 'eip155:1'),
    /**
   * The origin to send the transaction from. Defaults to `metamask.io`.
   */ origin: (0, _superstruct.defaulted)((0, _superstruct.string)(), 'metamask.io'),
    /**
   * The address to send the transaction from. Defaults to a randomly generated
   * address.
   */ // TODO: Move this coercer to `@metamask/utils`.
    from: (0, _superstruct.coerce)(_utils.StrictHexStruct, (0, _superstruct.optional)(BytesLikeStruct), (value)=>{
        if (value) {
            return (0, _utils.valueToBytes)(value);
        }
        return (0, _utils.bytesToHex)((0, _crypto.randomBytes)(20));
    }),
    /**
   * The address to send the transaction to. Defaults to a randomly generated
   * address.
   */ // TODO: Move this coercer to `@metamask/utils`.
    to: (0, _superstruct.coerce)(_utils.StrictHexStruct, (0, _superstruct.optional)(BytesLikeStruct), (value)=>{
        if (value) {
            return (0, _utils.valueToBytes)(value);
        }
        return (0, _utils.bytesToHex)((0, _crypto.randomBytes)(20));
    }),
    /**
   * The value to send with the transaction. The value may be specified as a
   * `number`, `bigint`, `string`, or `Uint8Array`. Defaults to `0`.
   */ value: (0, _superstruct.defaulted)((0, _superstruct.coerce)(_utils.StrictHexStruct, BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), '0x0'),
    /**
   * The gas limit to use for the transaction. The gas limit may be specified
   * as a `number`, `bigint`, `string`, or `Uint8Array`. Defaults to `21_000`.
   */ gasLimit: (0, _superstruct.defaulted)((0, _superstruct.coerce)(_utils.StrictHexStruct, BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), (0, _utils.valueToBytes)(21000)),
    /**
   * The max fee per gas (in Wei) to use for the transaction. The max fee per
   * gas may be specified as a `number`, `bigint`, `string`, or `Uint8Array`.
   * Defaults to `1`.
   */ maxFeePerGas: (0, _superstruct.defaulted)((0, _superstruct.coerce)(_utils.StrictHexStruct, BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), (0, _utils.valueToBytes)(1)),
    /**
   * The max priority fee per gas (in Wei) to use for the transaction. The max
   * priority fee per gas may be specified as a `number`, `bigint`, `string`,
   * or `Uint8Array`. Defaults to `1`.
   */ maxPriorityFeePerGas: (0, _superstruct.defaulted)((0, _superstruct.coerce)(_utils.StrictHexStruct, BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), (0, _utils.valueToBytes)(1)),
    /**
   * The nonce to use for the transaction. The nonce may be specified as a
   * `number`, `bigint`, `string`, or `Uint8Array`. Defaults to `0`.
   */ nonce: (0, _superstruct.defaulted)((0, _superstruct.coerce)(_utils.StrictHexStruct, BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), (0, _utils.valueToBytes)(0)),
    /**
   * The data to send with the transaction. The data may be specified as a
   * `number`, `bigint`, `string`, or `Uint8Array`. Defaults to `0x`.
   */ data: (0, _superstruct.defaulted)((0, _superstruct.coerce)((0, _superstruct.union)([
        _utils.StrictHexStruct,
        (0, _superstruct.literal)('0x')
    ]), BytesLikeStruct, (value)=>(0, _utils.bytesToHex)((0, _utils.valueToBytes)(value))), '0x')
});
const SnapOptionsStruct = (0, _superstruct.object)({
    /**
   * The timeout in milliseconds to use for requests to the snap. Defaults to
   * `1000`.
   */ timeout: (0, _superstruct.defaulted)((0, _superstruct.optional)((0, _superstruct.number)()), 1000)
});
const InterfaceStruct = (0, _superstruct.type)({
    content: (0, _superstruct.optional)(_snapsui.ComponentStruct)
});
const SnapResponseStruct = (0, _superstruct.assign)(InterfaceStruct, (0, _superstruct.object)({
    id: (0, _superstruct.string)(),
    response: (0, _superstruct.union)([
        (0, _superstruct.object)({
            result: _utils.JsonStruct
        }),
        (0, _superstruct.object)({
            error: _utils.JsonStruct
        })
    ]),
    notifications: (0, _superstruct.array)((0, _superstruct.object)({
        id: (0, _superstruct.string)(),
        message: (0, _superstruct.string)(),
        type: (0, _superstruct.union)([
            (0, _snapsutils.enumValue)(_rpcmethods.NotificationType.InApp),
            (0, _snapsutils.enumValue)(_rpcmethods.NotificationType.Native)
        ])
    }))
}));

//# sourceMappingURL=structs.js.map