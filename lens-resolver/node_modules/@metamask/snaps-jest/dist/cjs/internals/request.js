"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    request: function() {
        return request;
    },
    sendTransaction: function() {
        return sendTransaction;
    },
    runCronjob: function() {
        return runCronjob;
    }
});
const _snapsutils = require("@metamask/snaps-utils");
const _utils = require("@metamask/utils");
const _pptrtestinglibrary = require("pptr-testing-library");
const _superstruct = require("superstruct");
const _interface = require("./interface");
const _logger = require("./logger");
const _structs = require("./structs");
const _waitfor = require("./wait-for");
const log = (0, _utils.createModuleLogger)(_logger.rootLogger, 'request');
/**
 * Send a request to the snap.
 *
 * @param page - The page to send the request from.
 * @param args - The request arguments.
 * @returns The request ID.
 */ async function sendRequest(page, args) {
    const document = await (0, _pptrtestinglibrary.getDocument)(page);
    const button = await _pptrtestinglibrary.queries.getByTestId(document, `navigation-${args.handler}`);
    // Navigate to the request handler page.
    await button.click();
    return await page.evaluate((payload)=>{
        window.__SIMULATOR_API__.dispatch({
            type: 'simulation/sendRequest',
            payload
        });
        return window.__SIMULATOR_API__.getRequestId();
    }, args);
}
function request(page, { origin = 'metamask.io', ...options }, handler = _snapsutils.HandlerType.OnRpcRequest) {
    const doRequest = async ()=>{
        const args = {
            origin,
            handler,
            request: {
                jsonrpc: '2.0',
                id: 1,
                ...options
            }
        };
        log('Sending request %o', args);
        const promise = (0, _waitfor.waitForResponse)(page, handler);
        const id = await sendRequest(page, args);
        const response = await promise;
        log('Received response %o', response);
        const notifications = await (0, _interface.getNotifications)(page, id);
        return {
            id,
            response,
            notifications
        };
    };
    // This is a bit hacky, but it allows us to add the `getInterface` method
    // to the response promise.
    const response = doRequest();
    response.getInterface = async (getInterfaceOptions)=>{
        return await (0, _interface.getInterface)(page, getInterfaceOptions);
    };
    return response;
}
async function sendTransaction(page, options) {
    const { origin: transactionOrigin, chainId, ...transaction } = (0, _superstruct.create)(options, _structs.TransactionOptionsStruct);
    const args = {
        origin: '',
        handler: _snapsutils.HandlerType.OnTransaction,
        request: {
            jsonrpc: '2.0',
            method: '',
            params: {
                chainId,
                transaction,
                transactionOrigin
            }
        }
    };
    log('Sending transaction %o', args);
    const promise = (0, _waitfor.waitForResponse)(page, _snapsutils.HandlerType.OnTransaction);
    const id = await sendRequest(page, args);
    const response = await promise;
    log('Received response %o', response);
    if ((0, _utils.hasProperty)(response, 'error')) {
        return {
            id,
            response,
            notifications: []
        };
    }
    (0, _utils.assert)((0, _utils.isPlainObject)(response.result));
    (0, _utils.assert)((0, _utils.hasProperty)(response.result, 'content'));
    return {
        id,
        response,
        notifications: [],
        content: response.result.content
    };
}
function runCronjob(page, options) {
    return request(page, options, _snapsutils.HandlerType.OnCronjob);
}

//# sourceMappingURL=request.js.map