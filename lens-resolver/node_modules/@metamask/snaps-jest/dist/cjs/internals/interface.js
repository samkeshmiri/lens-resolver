"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getInterface: function() {
        return getInterface;
    },
    getNotifications: function() {
        return getNotifications;
    }
});
const _rpcmethods = require("@metamask/rpc-methods");
const _utils = require("@metamask/utils");
const _superstruct = require("superstruct");
const _structs = require("./structs");
const _waitfor = require("./wait-for");
async function getInterface(page, options = {}) {
    const { timeout } = (0, _superstruct.create)(options, _structs.SnapOptionsStruct);
    const { type, node: content } = await (0, _waitfor.waitFor)(async ()=>{
        const ui = await page.evaluate(()=>{
            const state = window.__SIMULATOR_API__.getState();
            return state.simulation.ui;
        });
        (0, _utils.assert)(ui);
        return ui;
    }, {
        timeout,
        message: 'Timed out waiting for snap interface to be shown.'
    });
    switch(type){
        case _rpcmethods.DialogType.Alert:
            return {
                type: 'alert',
                content,
                ok: async ()=>{
                    await page.evaluate(()=>{
                        window.__SIMULATOR_API__.dispatch({
                            type: 'simulation/resolveUserInterface',
                            payload: null
                        });
                    });
                }
            };
        case _rpcmethods.DialogType.Confirmation:
            return {
                type: 'confirmation',
                content,
                ok: async ()=>{
                    await page.evaluate(()=>{
                        window.__SIMULATOR_API__.dispatch({
                            type: 'simulation/resolveUserInterface',
                            payload: true
                        });
                    });
                },
                cancel: async ()=>{
                    await page.evaluate(()=>{
                        window.__SIMULATOR_API__.dispatch({
                            type: 'simulation/resolveUserInterface',
                            payload: false
                        });
                    });
                }
            };
        case _rpcmethods.DialogType.Prompt:
            return {
                type: 'prompt',
                content,
                ok: async (value)=>{
                    await page.evaluate((payload)=>{
                        window.__SIMULATOR_API__.dispatch({
                            type: 'simulation/resolveUserInterface',
                            payload
                        });
                    }, value);
                },
                cancel: async ()=>{
                    await page.evaluate(()=>{
                        window.__SIMULATOR_API__.dispatch({
                            type: 'simulation/resolveUserInterface',
                            payload: null
                        });
                    });
                }
            };
        default:
            throw new Error(`Unknown or unsupported dialog type: ${String(type)}.`);
    }
}
async function getNotifications(page, requestId) {
    return await page.evaluate((id)=>{
        return window.__SIMULATOR_API__.getNotifications(id);
    }, requestId);
}

//# sourceMappingURL=interface.js.map