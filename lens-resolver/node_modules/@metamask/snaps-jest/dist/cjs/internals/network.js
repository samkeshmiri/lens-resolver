"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MockOptionsStruct: function() {
        return MockOptionsStruct;
    },
    mock: function() {
        return mock;
    },
    mockJsonRpc: function() {
        return mockJsonRpc;
    }
});
const _snapssimulator = require("@metamask/snaps-simulator");
const _utils = require("@metamask/utils");
const _superstruct = require("superstruct");
const _logger = require("./logger");
/**
 * The default headers to use for mocked responses. These headers are used to
 * enable CORS.
 */ const DEFAULT_HEADERS = {
    /* eslint-disable @typescript-eslint/naming-convention */ 'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Credentials': 'true',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers'
};
const log = (0, _utils.createModuleLogger)(_logger.rootLogger, 'network');
const MockOptionsBaseStruct = (0, _superstruct.object)({
    response: (0, _superstruct.defaulted)((0, _superstruct.object)({
        status: (0, _superstruct.defaulted)((0, _superstruct.number)(), 200),
        headers: (0, _superstruct.defaulted)((0, _superstruct.record)((0, _superstruct.string)(), (0, _superstruct.unknown)()), DEFAULT_HEADERS),
        contentType: (0, _superstruct.defaulted)((0, _superstruct.string)(), 'text/plain'),
        // Note: We default to a newline here, because the fetch request never
        // resolves if the body is empty.
        body: (0, _superstruct.defaulted)((0, _superstruct.string)(), '\n')
    }), {})
});
const MockOptionsUrlStruct = (0, _superstruct.object)({
    url: (0, _superstruct.union)([
        (0, _superstruct.string)(),
        (0, _superstruct.regexp)()
    ]),
    partial: (0, _superstruct.optional)((0, _superstruct.boolean)())
});
const MockOptionsConditionStruct = (0, _superstruct.object)({
    condition: (0, _superstruct.func)()
});
const MockOptionsStruct = (0, _superstruct.union)([
    (0, _superstruct.assign)(MockOptionsBaseStruct, MockOptionsUrlStruct),
    (0, _superstruct.assign)(MockOptionsBaseStruct, MockOptionsConditionStruct)
]);
/**
 * Check if the given URL matches the given request, or if the condition
 * function returns `true`.
 *
 * @param request - The request to check.
 * @param options - The options for the network mocking.
 * @returns Whether the URL matches the request.
 */ function matches(request, options) {
    if ('url' in options) {
        const { url, partial } = options;
        if (typeof url === 'string') {
            if (partial) {
                return request.url().startsWith(url);
            }
            return url === request.url();
        }
        return url.test(request.url());
    }
    const { condition } = options;
    return condition(request);
}
async function mock(page, options) {
    await page.setRequestInterception(true);
    const parsedOptions = (0, _superstruct.create)(options, MockOptionsStruct);
    /**
   * The mock handler.
   *
   * @param request - The request to handle.
   */ function handler(request) {
        // If the request is already handled, Puppeteer will throw an error if we
        // try to continue the request.
        if (request.isInterceptResolutionHandled()) {
            return;
        }
        if (!matches(request, parsedOptions)) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            request.continue();
            return;
        }
        log('Mocking request to %s', request.url());
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        request.respond(parsedOptions.response);
    }
    /**
   * Unmock the page.
   */ async function unmock() {
        await page.setRequestInterception(false);
        page.off('request', handler);
    }
    page.on('request', handler);
    return {
        unmock
    };
}
const MockJsonRpcOptionsStruct = (0, _superstruct.object)({
    method: (0, _superstruct.string)(),
    result: _utils.UnsafeJsonStruct
});
async function mockJsonRpc(page, { method, result }) {
    return await mock(page, {
        condition: (request)=>{
            if (request.url() !== _snapssimulator.JSON_RPC_ENDPOINT) {
                return false;
            }
            const body = request.postData();
            if (!body) {
                return false;
            }
            try {
                const json = JSON.parse(body);
                return json.method === method;
            } catch (error) {
                log(`Unable to mock "${method}" request to Ethereum provider: %s`, error.message);
                return false;
            }
        },
        response: {
            status: 200,
            contentType: 'application/json',
            body: JSON.stringify({
                jsonrpc: '2.0',
                id: 1,
                result
            })
        }
    });
}

//# sourceMappingURL=network.js.map