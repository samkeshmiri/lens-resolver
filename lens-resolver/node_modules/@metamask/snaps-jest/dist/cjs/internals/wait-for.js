"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    waitFor: function() {
        return waitFor;
    },
    waitForResponse: function() {
        return waitForResponse;
    }
});
const _utils = require("@metamask/utils");
const _pptrtestinglibrary = require("pptr-testing-library");
const _logger = require("./logger");
const log = (0, _utils.createModuleLogger)(_logger.rootLogger, 'wait-for');
async function waitFor(fn, { timeout = 3000, message } = {}) {
    try {
        let result;
        await (0, _pptrtestinglibrary.waitFor)(// eslint-disable-next-line @typescript-eslint/no-misused-promises
        async ()=>{
            // Puppeteer's `waitFor` function does not support returning a value
            // from the condition function, so we need to use a variable outside
            // the scope of the function.
            result = await fn();
        }, {
            timeout
        });
        (0, _utils.assert)(result !== undefined);
        return result;
    } catch (error) {
        if (message) {
            throw new Error(message);
        }
        throw error;
    }
}
async function waitForResponse(page, type) {
    log('Waiting for response of type %s.', type);
    return await page.evaluate(async (_type)=>{
        return new Promise((resolve)=>{
            window.__SIMULATOR_API__.dispatch({
                type: `${_type}/clearResponse`
            });
            const unsubscribe = window.__SIMULATOR_API__.subscribe(()=>{
                const state = window.__SIMULATOR_API__.getState();
                const { pending, response } = state[_type];
                if (!pending && response) {
                    unsubscribe();
                    resolve(response);
                }
            });
        });
    }, type);
}

//# sourceMappingURL=wait-for.js.map