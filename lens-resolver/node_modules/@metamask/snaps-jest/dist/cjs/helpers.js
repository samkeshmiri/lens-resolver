"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "installSnap", {
    enumerable: true,
    get: function() {
        return installSnap;
    }
});
const _utils = require("@metamask/utils");
const _pptrtestinglibrary = require("pptr-testing-library");
const _internals = require("./internals");
// eslint-disable-next-line @typescript-eslint/unbound-method
const { getByTestId } = _pptrtestinglibrary.queries;
const log = (0, _utils.createModuleLogger)(_internals.rootLogger, 'helpers');
async function installSnap(snapId = (0, _internals.getEnvironment)().snapId) {
    const environment = (0, _internals.getEnvironment)();
    log('Installing snap %s.', snapId);
    const page = await environment.createPage();
    const document = await (0, _pptrtestinglibrary.getDocument)(page);
    log('Setting snap ID to %s.', snapId);
    await page.evaluate((payload)=>{
        window.__SIMULATOR_API__.dispatch({
            type: 'configuration/setSnapId',
            payload
        });
    }, snapId);
    log('Waiting for snap to install.');
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    await (0, _internals.waitFor)(async ()=>await getByTestId(document, 'status-ok'), {
        timeout: 10000,
        message: `Timed out waiting for snap to install. Make sure the snap ID ("${snapId}") is correct, and the server is running.`
    });
    return {
        request: (options)=>{
            log('Sending request %o.', options);
            // Note: This function is intentionally not async, so that we can access
            // the `getInterface` method on the response.
            return (0, _internals.request)(page, options);
        },
        sendTransaction: async (options = {})=>{
            log('Sending transaction %o.', options);
            return await (0, _internals.sendTransaction)(page, options);
        },
        runCronjob: (options)=>{
            log('Running cronjob %o.', options);
            // Note: This function is intentionally not async, so that we can access
            // the `getInterface` method on the response.
            return (0, _internals.runCronjob)(page, options);
        },
        close: async ()=>{
            log('Closing page.');
            await page.close();
        },
        mock: async (options)=>{
            log('Mocking %o.', options);
            return await (0, _internals.mock)(page, options);
        },
        mockJsonRpc: async (options)=>{
            log('Mocking JSON-RPC %o.', options);
            return await (0, _internals.mockJsonRpc)(page, options);
        }
    };
}

//# sourceMappingURL=helpers.js.map