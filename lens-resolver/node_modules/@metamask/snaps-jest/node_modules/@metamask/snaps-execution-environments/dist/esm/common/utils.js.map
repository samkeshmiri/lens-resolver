{"version":3,"sources":["../../../src/common/utils.ts"],"sourcesContent":["import type { StreamProvider } from '@metamask/providers';\nimport type { RequestArguments } from '@metamask/providers/dist/BaseProvider';\nimport { assert, assertStruct, JsonStruct } from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\n\nimport { log } from '../logging';\n\n/**\n * Takes an error that was thrown, determines if it is\n * an error object. If it is then it will return that. Otherwise,\n * an error object is created with the original error message.\n *\n * @param originalError - The error that was originally thrown.\n * @returns An error object.\n */\nexport function constructError(originalError: unknown) {\n  let _originalError: Error | undefined;\n  if (originalError instanceof Error) {\n    _originalError = originalError;\n  } else if (typeof originalError === 'string') {\n    _originalError = new Error(originalError);\n    // The stack is useless in this case.\n    delete _originalError.stack;\n  }\n  return _originalError;\n}\n\n/**\n * Make proxy for Promise and handle the teardown process properly.\n * If the teardown is called in the meanwhile, Promise result will not be\n * exposed to the snap anymore and warning will be logged to the console.\n *\n * @param originalPromise - Original promise.\n * @param teardownRef - Reference containing teardown count.\n * @param teardownRef.lastTeardown - Number of the last teardown.\n * @returns New proxy promise.\n */\nexport async function withTeardown<Type>(\n  originalPromise: Promise<Type>,\n  teardownRef: { lastTeardown: number },\n): Promise<Type> {\n  const myTeardown = teardownRef.lastTeardown;\n  return new Promise<Type>((resolve, reject) => {\n    originalPromise\n      .then((value) => {\n        if (teardownRef.lastTeardown === myTeardown) {\n          resolve(value);\n        } else {\n          log(\n            'Late promise received after Snap finished execution. Promise will be dropped.',\n          );\n        }\n      })\n      .catch((reason) => {\n        if (teardownRef.lastTeardown === myTeardown) {\n          reject(reason);\n        } else {\n          log(\n            'Late promise received after Snap finished execution. Promise will be dropped.',\n          );\n        }\n      });\n  });\n}\n\n/**\n * Returns a Proxy that narrows down (attenuates) the fields available on\n * the StreamProvider and replaces the request implementation.\n *\n * @param provider - Instance of a StreamProvider to be limited.\n * @param request - Custom attenuated request object.\n * @returns Proxy to the StreamProvider instance.\n */\nexport function proxyStreamProvider(\n  provider: StreamProvider,\n  request: unknown,\n): StreamProvider {\n  // Proxy target is intentionally set to be an empty object, to ensure\n  // that access to the prototype chain is not possible.\n  const proxy = new Proxy(\n    {},\n    {\n      has(_target: object, prop: string | symbol) {\n        return (\n          typeof prop === 'string' &&\n          ['request', 'on', 'removeListener'].includes(prop)\n        );\n      },\n      get(_target, prop: keyof StreamProvider) {\n        if (prop === 'request') {\n          return request;\n        } else if (['on', 'removeListener'].includes(prop)) {\n          return provider[prop];\n        }\n\n        return undefined;\n      },\n    },\n  );\n\n  return proxy as StreamProvider;\n}\n\n// We're blocking these RPC methods for v1, will revisit later.\nexport const BLOCKED_RPC_METHODS = Object.freeze([\n  'wallet_requestSnaps',\n  'wallet_requestPermissions',\n  // We disallow all of these confirmations for now, since the screens are not ready for Snaps.\n  'eth_sendRawTransaction',\n  'eth_sendTransaction',\n  'eth_sign',\n  'eth_signTypedData',\n  'eth_signTypedData_v1',\n  'eth_signTypedData_v3',\n  'eth_signTypedData_v4',\n  'eth_decrypt',\n  'eth_getEncryptionPublicKey',\n  'wallet_addEthereumChain',\n  'wallet_switchEthereumChain',\n  'wallet_watchAsset',\n  'wallet_registerOnboarding',\n  'wallet_scanQRCode',\n]);\n\n/**\n * Asserts the validity of request arguments for a snap outbound request using the `snap.request` API.\n *\n * @param args - The arguments to validate.\n */\nexport function assertSnapOutboundRequest(args: RequestArguments) {\n  // Disallow any non `wallet_` or `snap_` methods for separation of concerns.\n  assert(\n    String.prototype.startsWith.call(args.method, 'wallet_') ||\n      String.prototype.startsWith.call(args.method, 'snap_'),\n    'The global Snap API only allows RPC methods starting with `wallet_*` and `snap_*`.',\n  );\n  assert(\n    !BLOCKED_RPC_METHODS.includes(args.method),\n    ethErrors.rpc.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assertStruct(args, JsonStruct, 'Provided value is not JSON-RPC compatible');\n}\n\n/**\n * Asserts the validity of request arguments for an ethereum outbound request using the `ethereum.request` API.\n *\n * @param args - The arguments to validate.\n */\nexport function assertEthereumOutboundRequest(args: RequestArguments) {\n  // Disallow snaps methods for separation of concerns.\n  assert(\n    !String.prototype.startsWith.call(args.method, 'snap_'),\n    ethErrors.rpc.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assert(\n    !BLOCKED_RPC_METHODS.includes(args.method),\n    ethErrors.rpc.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assertStruct(args, JsonStruct, 'Provided value is not JSON-RPC compatible');\n}\n"],"names":["assert","assertStruct","JsonStruct","ethErrors","log","constructError","originalError","_originalError","Error","stack","withTeardown","originalPromise","teardownRef","myTeardown","lastTeardown","Promise","resolve","reject","then","value","catch","reason","proxyStreamProvider","provider","request","proxy","Proxy","has","_target","prop","includes","get","undefined","BLOCKED_RPC_METHODS","Object","freeze","assertSnapOutboundRequest","args","String","prototype","startsWith","call","method","rpc","methodNotFound","data","assertEthereumOutboundRequest"],"mappings":"AAEA,SAASA,MAAM,EAAEC,YAAY,EAAEC,UAAU,QAAQ,kBAAkB;AACnE,SAASC,SAAS,QAAQ,iBAAiB;AAE3C,SAASC,GAAG,QAAQ,aAAa;AAEjC;;;;;;;CAOC,GACD,OAAO,SAASC,eAAeC,aAAsB;IACnD,IAAIC;IACJ,IAAID,yBAAyBE,OAAO;QAClCD,iBAAiBD;IACnB,OAAO,IAAI,OAAOA,kBAAkB,UAAU;QAC5CC,iBAAiB,IAAIC,MAAMF;QAC3B,qCAAqC;QACrC,OAAOC,eAAeE,KAAK;IAC7B;IACA,OAAOF;AACT;AAEA;;;;;;;;;CASC,GACD,OAAO,eAAeG,aACpBC,eAA8B,EAC9BC,WAAqC;IAErC,MAAMC,aAAaD,YAAYE,YAAY;IAC3C,OAAO,IAAIC,QAAc,CAACC,SAASC;QACjCN,gBACGO,IAAI,CAAC,CAACC;YACL,IAAIP,YAAYE,YAAY,KAAKD,YAAY;gBAC3CG,QAAQG;YACV,OAAO;gBACLf,IACE;YAEJ;QACF,GACCgB,KAAK,CAAC,CAACC;YACN,IAAIT,YAAYE,YAAY,KAAKD,YAAY;gBAC3CI,OAAOI;YACT,OAAO;gBACLjB,IACE;YAEJ;QACF;IACJ;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,SAASkB,oBACdC,QAAwB,EACxBC,OAAgB;IAEhB,qEAAqE;IACrE,sDAAsD;IACtD,MAAMC,QAAQ,IAAIC,MAChB,CAAC,GACD;QACEC,KAAIC,OAAe,EAAEC,IAAqB;YACxC,OACE,OAAOA,SAAS,YAChB;gBAAC;gBAAW;gBAAM;aAAiB,CAACC,QAAQ,CAACD;QAEjD;QACAE,KAAIH,OAAO,EAAEC,IAA0B;YACrC,IAAIA,SAAS,WAAW;gBACtB,OAAOL;YACT,OAAO,IAAI;gBAAC;gBAAM;aAAiB,CAACM,QAAQ,CAACD,OAAO;gBAClD,OAAON,QAAQ,CAACM,KAAK;YACvB;YAEA,OAAOG;QACT;IACF;IAGF,OAAOP;AACT;AAEA,+DAA+D;AAC/D,OAAO,MAAMQ,sBAAsBC,OAAOC,MAAM,CAAC;IAC/C;IACA;IACA,6FAA6F;IAC7F;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,EAAE;AAEH;;;;CAIC,GACD,OAAO,SAASC,0BAA0BC,IAAsB;IAC9D,4EAA4E;IAC5ErC,OACEsC,OAAOC,SAAS,CAACC,UAAU,CAACC,IAAI,CAACJ,KAAKK,MAAM,EAAE,cAC5CJ,OAAOC,SAAS,CAACC,UAAU,CAACC,IAAI,CAACJ,KAAKK,MAAM,EAAE,UAChD;IAEF1C,OACE,CAACiC,oBAAoBH,QAAQ,CAACO,KAAKK,MAAM,GACzCvC,UAAUwC,GAAG,CAACC,cAAc,CAAC;QAC3BC,MAAM;YACJH,QAAQL,KAAKK,MAAM;QACrB;IACF;IAEFzC,aAAaoC,MAAMnC,YAAY;AACjC;AAEA;;;;CAIC,GACD,OAAO,SAAS4C,8BAA8BT,IAAsB;IAClE,qDAAqD;IACrDrC,OACE,CAACsC,OAAOC,SAAS,CAACC,UAAU,CAACC,IAAI,CAACJ,KAAKK,MAAM,EAAE,UAC/CvC,UAAUwC,GAAG,CAACC,cAAc,CAAC;QAC3BC,MAAM;YACJH,QAAQL,KAAKK,MAAM;QACrB;IACF;IAEF1C,OACE,CAACiC,oBAAoBH,QAAQ,CAACO,KAAKK,MAAM,GACzCvC,UAAUwC,GAAG,CAACC,cAAc,CAAC;QAC3BC,MAAM;YACJH,QAAQL,KAAKK,MAAM;QACrB;IACF;IAEFzC,aAAaoC,MAAMnC,YAAY;AACjC"}