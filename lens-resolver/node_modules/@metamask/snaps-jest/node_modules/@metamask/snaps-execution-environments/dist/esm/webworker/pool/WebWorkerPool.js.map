{"version":3,"sources":["../../../../src/webworker/pool/WebWorkerPool.ts"],"sourcesContent":["import type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport {\n  WebWorkerParentPostMessageStream,\n  WindowPostMessageStream,\n} from '@metamask/post-message-stream';\nimport { logError } from '@metamask/snaps-utils';\nimport type { JsonRpcRequest } from '@metamask/utils';\nimport { assert } from '@metamask/utils';\nimport { nanoid } from 'nanoid/non-secure';\n\ntype ExecutorJob = {\n  id: string;\n  worker: Worker;\n  stream: WebWorkerParentPostMessageStream;\n};\n\n/**\n * A snap executor using the WebWorker API.\n *\n * This is not a traditional snap executor, as it does not execute snaps itself.\n * Instead, it creates a pool of webworkers for each snap execution, and sends\n * the snap execution request to the webworker. The webworker is responsible for\n * executing the snap.\n */\nexport class WebWorkerPool {\n  readonly #poolSize;\n\n  readonly #stream: BasePostMessageStream;\n\n  readonly #url: string;\n\n  readonly pool: Worker[] = [];\n\n  readonly jobs: Map<string, ExecutorJob> = new Map();\n\n  #workerSourceURL?: string;\n\n  /* istanbul ignore next - Constructor arguments. */\n  static initialize(\n    stream: BasePostMessageStream = new WindowPostMessageStream({\n      name: 'child',\n      target: 'parent',\n      targetWindow: self.parent,\n      targetOrigin: '*',\n    }),\n    url = '../executor/bundle.js',\n    poolSize?: number,\n  ) {\n    return new WebWorkerPool(stream, url, poolSize);\n  }\n\n  constructor(stream: BasePostMessageStream, url: string, poolSize = 3) {\n    this.#stream = stream;\n    this.#url = url;\n    this.#poolSize = poolSize;\n\n    this.#stream.on('data', this.#onData.bind(this));\n  }\n\n  /**\n   * Handle an incoming message from the `WebWorkerExecutionService`. This\n   * assumes that the message contains a `jobId` property, and a JSON-RPC\n   * request in the `data` property.\n   *\n   * @param data - The message data.\n   * @param data.data - The JSON-RPC request.\n   * @param data.jobId - The job ID.\n   */\n  #onData(data: { data: JsonRpcRequest; jobId: string }) {\n    const { jobId, data: request } = data;\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      // This ensures that a job is initialized before it is used. To avoid\n      // code duplication, we call the `#onData` method again, which will\n      // run the rest of the logic after initialization.\n      this.#initializeJob(jobId)\n        .then(() => {\n          this.#onData(data);\n        })\n        .catch((error) => {\n          logError('[Worker] Error initializing job:', error.toString());\n\n          this.#stream.write({\n            jobId,\n            data: {\n              name: 'command',\n              data: {\n                jsonrpc: '2.0',\n                id: request.id ?? null,\n                error: {\n                  code: -32000,\n                  message: 'Internal error',\n                },\n              },\n            },\n          });\n        });\n\n      return;\n    }\n\n    // This is a method specific to the `WebWorkerPool`, as the service itself\n    // does not have access to the workers directly.\n    if (request.method === 'terminateJob') {\n      this.#terminateJob(jobId);\n      return;\n    }\n\n    job.stream.write(request);\n  }\n\n  /**\n   * Create a new worker and set up a stream to communicate with it.\n   *\n   * @param jobId - The job ID.\n   * @returns The job.\n   */\n  async #initializeJob(jobId: string): Promise<ExecutorJob> {\n    const worker = await this.#getWorker();\n    const jobStream = new WebWorkerParentPostMessageStream({\n      worker,\n    });\n\n    // Write messages from the worker to the parent, wrapped with the job ID.\n    jobStream.on('data', (data) => {\n      this.#stream.write({ data, jobId });\n    });\n\n    const job = { id: jobId, worker, stream: jobStream };\n    this.jobs.set(jobId, job);\n    return job;\n  }\n\n  /**\n   * Terminate the job with the given ID. This will close the worker and delete\n   * the job from the internal job map.\n   *\n   * @param jobId - The job ID.\n   */\n  #terminateJob(jobId: string) {\n    const job = this.jobs.get(jobId);\n    assert(job, `Job \"${jobId}\" not found.`);\n\n    job.stream.destroy();\n    job.worker.terminate();\n\n    this.jobs.delete(jobId);\n  }\n\n  /**\n   * Get a worker from the pool. A new worker will be created automatically.\n   *\n   * @returns The worker.\n   */\n  async #getWorker() {\n    // Lazily create the pool of workers.\n    if (this.pool.length === 0) {\n      await this.#updatePool();\n    }\n\n    const worker = this.pool.shift();\n    assert(worker, 'Worker not found.');\n\n    await this.#updatePool();\n\n    return worker;\n  }\n\n  /**\n   * Update the pool of workers. This will create new workers if the pool is\n   * below the minimum size.\n   */\n  async #updatePool() {\n    while (this.pool.length < this.#poolSize) {\n      const worker = await this.#createWorker();\n      this.pool.push(worker);\n    }\n  }\n\n  /**\n   * Create a new worker. This will fetch the worker source if it has not\n   * already been fetched.\n   *\n   * @returns The worker.\n   */\n  async #createWorker() {\n    return new Worker(await this.#getWorkerURL(), {\n      name: `worker-${nanoid()}`,\n    });\n  }\n\n  /**\n   * Get the URL of the worker source. This will fetch the worker source if it\n   * has not already been fetched.\n   *\n   * @returns The worker source URL, as a `blob:` URL.\n   */\n  async #getWorkerURL() {\n    if (this.#workerSourceURL) {\n      return this.#workerSourceURL;\n    }\n\n    const blob = await fetch(this.#url)\n      .then(async (response) => response.blob())\n      .then(URL.createObjectURL.bind(URL));\n\n    this.#workerSourceURL = blob;\n    return blob;\n  }\n}\n"],"names":["WebWorkerParentPostMessageStream","WindowPostMessageStream","logError","assert","nanoid","WebWorkerPool","initialize","stream","name","target","targetWindow","self","parent","targetOrigin","url","poolSize","constructor","pool","jobs","Map","on","onData","bind","data","jobId","request","job","get","initializeJob","then","catch","error","toString","write","jsonrpc","id","code","message","method","terminateJob","worker","getWorker","jobStream","set","destroy","terminate","delete","length","updatePool","shift","createWorker","push","Worker","getWorkerURL","workerSourceURL","blob","fetch","response","URL","createObjectURL"],"mappings":"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"}