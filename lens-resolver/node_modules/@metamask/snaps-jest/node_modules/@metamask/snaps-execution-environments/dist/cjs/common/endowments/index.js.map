{"version":3,"sources":["../../../../src/common/endowments/index.ts"],"sourcesContent":["import type { StreamProvider } from '@metamask/providers';\nimport type { SnapsGlobalObject } from '@metamask/rpc-methods';\nimport type { SnapId } from '@metamask/snaps-utils';\nimport { logWarning } from '@metamask/snaps-utils';\nimport { hasProperty } from '@metamask/utils';\n\nimport { rootRealmGlobal } from '../globalObject';\nimport type { EndowmentFactoryOptions } from './commonEndowmentFactory';\nimport buildCommonEndowments from './commonEndowmentFactory';\n\ntype EndowmentFactoryResult = {\n  /**\n   * A function that performs any necessary teardown when the snap becomes idle.\n   *\n   * NOTE:** The endowments are not reconstructed if the snap is re-invoked\n   * before being terminated, so the teardown operation must not render the\n   * endowments unusable; it should simply restore the endowments to their\n   * original state.\n   */\n  teardownFunction?: () => Promise<void> | void;\n  [key: string]: unknown;\n};\n\n/**\n * Retrieve consolidated endowment factories for common endowments.\n */\nconst registeredEndowments = buildCommonEndowments();\n\n/**\n * A map of endowment names to their factory functions. Some endowments share\n * the same factory function, but we only call each factory once for each snap.\n * See {@link createEndowments} for details.\n */\nconst endowmentFactories = registeredEndowments.reduce((factories, builder) => {\n  builder.names.forEach((name) => {\n    factories.set(name, builder.factory);\n  });\n  return factories;\n}, new Map<string, (options?: EndowmentFactoryOptions) => EndowmentFactoryResult>());\n\n/**\n * Gets the endowments for a particular Snap. Some endowments, like `setTimeout`\n * and `clearTimeout`, must be attenuated so that they can only affect behavior\n * within the Snap's own realm. Therefore, we use factory functions to create\n * such attenuated / modified endowments. Otherwise, the value that's on the\n * root realm global will be used.\n *\n * @param snap - The Snaps global API object.\n * @param ethereum - The Snap's EIP-1193 provider object.\n * @param snapId - The id of the snap that will use the created endowments.\n * @param endowments - The list of endowments to provide to the snap.\n * @returns An object containing the Snap's endowments.\n */\nexport function createEndowments(\n  snap: SnapsGlobalObject,\n  ethereum: StreamProvider,\n  snapId: SnapId,\n  endowments: string[] = [],\n): { endowments: Record<string, unknown>; teardown: () => Promise<void> } {\n  const attenuatedEndowments: Record<string, unknown> = {};\n\n  // TODO: All endowments should be hardened to prevent covert communication\n  // channels. Hardening the returned objects breaks tests elsewhere in the\n  // monorepo, so further research is needed.\n  const result = endowments.reduce<{\n    allEndowments: Record<string, unknown>;\n    teardowns: (() => Promise<void> | void)[];\n  }>(\n    ({ allEndowments, teardowns }, endowmentName) => {\n      // First, check if the endowment has a factory, and default to that.\n      if (endowmentFactories.has(endowmentName)) {\n        if (!hasProperty(attenuatedEndowments, endowmentName)) {\n          // Call the endowment factory for the current endowment. If the factory\n          // creates multiple endowments, they will all be assigned to the\n          // `attenuatedEndowments` object, but will only be passed on to the snap\n          // if explicitly listed among its endowment.\n          // This may not have an actual use case, but, safety first.\n\n          // We just confirmed that endowmentFactories has the specified key.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const { teardownFunction, ...endowment } = endowmentFactories.get(\n            endowmentName,\n          )!({ snapId });\n          Object.assign(attenuatedEndowments, endowment);\n          if (teardownFunction) {\n            teardowns.push(teardownFunction);\n          }\n        }\n        allEndowments[endowmentName] = attenuatedEndowments[endowmentName];\n      } else if (endowmentName === 'ethereum') {\n        // Special case for adding the EIP-1193 provider.\n        allEndowments[endowmentName] = ethereum;\n      } else if (endowmentName in rootRealmGlobal) {\n        logWarning(`Access to unhardened global ${endowmentName}.`);\n        // If the endowment doesn't have a factory, just use whatever is on the\n        // global object.\n        const globalValue = (rootRealmGlobal as Record<string, unknown>)[\n          endowmentName\n        ];\n        allEndowments[endowmentName] = globalValue;\n      } else {\n        // If we get to this point, we've been passed an endowment that doesn't\n        // exist in our current environment.\n        throw new Error(`Unknown endowment: \"${endowmentName}\".`);\n      }\n      return { allEndowments, teardowns };\n    },\n    {\n      allEndowments: { snap },\n      teardowns: [],\n    },\n  );\n\n  const teardown = async () => {\n    await Promise.all(\n      result.teardowns.map((teardownFunction) => teardownFunction()),\n    );\n  };\n  return { endowments: result.allEndowments, teardown };\n}\n"],"names":["createEndowments","registeredEndowments","buildCommonEndowments","endowmentFactories","reduce","factories","builder","names","forEach","name","set","factory","Map","snap","ethereum","snapId","endowments","attenuatedEndowments","result","allEndowments","teardowns","endowmentName","has","hasProperty","teardownFunction","endowment","get","Object","assign","push","rootRealmGlobal","logWarning","globalValue","Error","teardown","Promise","all","map"],"mappings":";;;;+BAqDgBA;;;eAAAA;;;4BAlDW;uBACC;8BAEI;+EAEE;;;;;;AAelC;;CAEC,GACD,MAAMC,uBAAuBC,IAAAA,+BAAqB;AAElD;;;;CAIC,GACD,MAAMC,qBAAqBF,qBAAqBG,MAAM,CAAC,CAACC,WAAWC;IACjEA,QAAQC,KAAK,CAACC,OAAO,CAAC,CAACC;QACrBJ,UAAUK,GAAG,CAACD,MAAMH,QAAQK,OAAO;IACrC;IACA,OAAON;AACT,GAAG,IAAIO;AAeA,SAASZ,iBACda,IAAuB,EACvBC,QAAwB,EACxBC,MAAc,EACdC,aAAuB,EAAE;IAEzB,MAAMC,uBAAgD,CAAC;IAEvD,0EAA0E;IAC1E,yEAAyE;IACzE,2CAA2C;IAC3C,MAAMC,SAASF,WAAWZ,MAAM,CAI9B,CAAC,EAAEe,aAAa,EAAEC,SAAS,EAAE,EAAEC;QAC7B,oEAAoE;QACpE,IAAIlB,mBAAmBmB,GAAG,CAACD,gBAAgB;YACzC,IAAI,CAACE,IAAAA,kBAAW,EAACN,sBAAsBI,gBAAgB;gBACrD,uEAAuE;gBACvE,gEAAgE;gBAChE,wEAAwE;gBACxE,4CAA4C;gBAC5C,2DAA2D;gBAE3D,mEAAmE;gBACnE,oEAAoE;gBACpE,MAAM,EAAEG,gBAAgB,EAAE,GAAGC,WAAW,GAAGtB,mBAAmBuB,GAAG,CAC/DL,eACC;oBAAEN;gBAAO;gBACZY,OAAOC,MAAM,CAACX,sBAAsBQ;gBACpC,IAAID,kBAAkB;oBACpBJ,UAAUS,IAAI,CAACL;gBACjB;YACF;YACAL,aAAa,CAACE,cAAc,GAAGJ,oBAAoB,CAACI,cAAc;QACpE,OAAO,IAAIA,kBAAkB,YAAY;YACvC,iDAAiD;YACjDF,aAAa,CAACE,cAAc,GAAGP;QACjC,OAAO,IAAIO,iBAAiBS,6BAAe,EAAE;YAC3CC,IAAAA,sBAAU,EAAC,CAAC,4BAA4B,EAAEV,cAAc,CAAC,CAAC;YAC1D,uEAAuE;YACvE,iBAAiB;YACjB,MAAMW,cAAc,AAACF,6BAAe,AAA4B,CAC9DT,cACD;YACDF,aAAa,CAACE,cAAc,GAAGW;QACjC,OAAO;YACL,uEAAuE;YACvE,oCAAoC;YACpC,MAAM,IAAIC,MAAM,CAAC,oBAAoB,EAAEZ,cAAc,EAAE,CAAC;QAC1D;QACA,OAAO;YAAEF;YAAeC;QAAU;IACpC,GACA;QACED,eAAe;YAAEN;QAAK;QACtBO,WAAW,EAAE;IACf;IAGF,MAAMc,WAAW;QACf,MAAMC,QAAQC,GAAG,CACflB,OAAOE,SAAS,CAACiB,GAAG,CAAC,CAACb,mBAAqBA;IAE/C;IACA,OAAO;QAAER,YAAYE,OAAOC,aAAa;QAAEe;IAAS;AACtD"}