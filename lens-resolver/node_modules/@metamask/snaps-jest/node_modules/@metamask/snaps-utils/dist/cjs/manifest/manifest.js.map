{"version":3,"sources":["../../../src/manifest/manifest.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames, SnapValidationFailureReason } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file';\nimport type { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialPermissions: 7,\n  manifestVersion: 8,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @param writeFileFn - The function to use to write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n  writeFileFn: WriteFileFunction = fs.writeFile,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          validateNpmSnapManifest({ ...partiallyValidatedFiles, manifest });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): VirtualFile<SnapManifest> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap bundle file: ${error.message}`);\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${error.message}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an npm Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n */\nexport function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  validateSnapShasum(\n    { manifest, sourceCode, svgIcon },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n"],"names":["checkManifest","fixManifest","getSnapSourceCode","getSnapIcon","getWritableManifest","validateNpmSnapManifest","MANIFEST_SORT_ORDER","$schema","version","description","proposedName","repository","source","initialPermissions","manifestVersion","basePath","writeManifest","sourceCode","writeFileFn","fs","writeFile","warnings","errors","updated","manifestPath","pathUtils","join","NpmSnapFileNames","Manifest","manifestFile","readJsonFile","unvalidatedManifest","result","packageFile","PackageJson","snapFiles","manifest","packageJson","svgIcon","validateNpmSnap","error","ProgrammaticallyFixableSnapError","push","message","partiallyValidatedFiles","isInvalid","currentError","maxAttempts","Object","keys","SnapValidationFailureReason","length","attempts","nextValidationError","Error","assert","validatedManifest","recommendedFields","missingRecommendedFields","filter","key","reduce","allMissing","currentField","newManifest","JSON","stringify","value","clonedFile","clone","manifestCopy","reason","NameMismatch","location","npm","packageName","name","VersionMismatch","RepositoryMismatch","deepClone","undefined","ShasumMismatch","shasum","getSnapChecksum","assertExhaustive","isPlainObject","sourceFilePath","filePath","VirtualFile","path","virtualFile","readVirtualFile","iconPath","remaining","writableManifest","sort","a","b","packageJsonName","packageJsonVersion","packageJsonRepository","manifestPackageName","manifestPackageVersion","manifestRepository","deepEqual","validateSnapShasum"],"mappings":"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"}