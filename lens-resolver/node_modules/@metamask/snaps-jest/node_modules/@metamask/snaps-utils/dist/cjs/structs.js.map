{"version":3,"sources":["../../src/structs.ts"],"sourcesContent":["import { isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport { resolve } from 'path';\nimport type { Failure, Infer } from 'superstruct';\nimport {\n  Struct,\n  StructError,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n  create,\n  string,\n  coerce,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * A wrapper of `superstruct`'s `string` struct that coerces a value to a string\n * and resolves it relative to the current working directory. This is useful\n * for specifying file paths in a configuration file, as it allows the user to\n * use both relative and absolute paths.\n *\n * @returns The `superstruct` struct, which validates that the value is a\n * string, and resolves it relative to the current working directory.\n * @example\n * ```ts\n * const config = struct({\n *   file: file(),\n *   // ...\n * });\n *\n * const value = create({ file: 'path/to/file' }, config);\n * console.log(value.file); // /process/cwd/path/to/file\n * ```\n */\nexport function file() {\n  return coerce(string(), string(), (value) => {\n    return resolve(process.cwd(), value);\n  });\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(struct, [\n      ...failures(),\n    ])}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(struct, prefix, suffix, error, () =>\n    arrayToGenerator(error.failures()),\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => green(type));\n  }\n\n  return null;\n}\n\n/**\n * Get a error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${bold(failure.path.join('.'))} — `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n) {\n  const received = red(JSON.stringify(failure.value));\n  const prefix = getStructErrorPrefix(failure);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(/the literal `(.+)`,/u, `the value to be \\`${green('$1')}\\`,`)\n      .replace(/, but received: (.+)/u, `, but received: ${red('$1')}`);\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${bold(\n      failure.path.join('.'),\n    )}, received: ${received}.`;\n  }\n\n  return `${prefix}Expected a value of type ${green(\n    failure.type,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(`• ${getStructFailureMessage(struct, failure)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n"],"names":["literal","union","file","named","SnapsStructError","arrayToGenerator","getError","createFromStruct","getStructFromPath","getUnionStructNames","getStructErrorPrefix","getStructFailureMessage","getStructErrorMessage","value","define","JSON","stringify","superstructLiteral","validator","head","tail","struct","superstructUnion","Struct","schema","coerce","string","resolve","process","cwd","name","type","StructError","constructor","prefix","suffix","failure","failures","message","array","item","error","create","path","reduce","result","key","isObject","Array","isArray","map","green","length","bold","join","received","red","childStruct","unionNames","replace","formattedFailures","indent"],"mappings":"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"}