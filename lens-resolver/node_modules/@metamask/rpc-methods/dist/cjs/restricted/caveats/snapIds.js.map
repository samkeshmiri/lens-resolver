{"version":3,"sources":["../../../../src/restricted/caveats/snapIds.ts"],"sourcesContent":["import type {\n  Caveat,\n  RestrictedMethodOptions,\n  RestrictedMethodParameters,\n  RestrictedMethodCaveatSpecificationConstraint,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { SnapIds } from '@metamask/snaps-utils';\nimport { SnapCaveatType, SnapIdsStruct } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\nimport { hasProperty, assertStruct } from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { type } from 'superstruct';\n\nimport type { InvokeSnapParams } from '../invokeSnap';\n\n/**\n * Map a raw value from the `initialPermissions` to a caveat specification.\n * Note that this function does not do any validation, that's handled by the\n * PermissionsController when the permission is requested.\n *\n * @param value - The raw value from the `initialPermissions`.\n * @returns The caveat specification.\n */\nexport function snapIdsCaveatMapper(\n  value: Json,\n): Pick<PermissionConstraint, 'caveats'> {\n  return {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds,\n        value,\n      },\n    ],\n  };\n}\n\n/**\n * Validates that the caveat value exists and is a non-empty object.\n *\n * @param caveat - The caveat to validate.\n * @throws If the caveat is invalid.\n */\nexport function validateSnapIdsCaveat(\n  caveat: Caveat<string, any>,\n): asserts caveat is Caveat<string, SnapIds> {\n  assertStruct(\n    caveat,\n    type({\n      value: SnapIdsStruct,\n    }),\n    'Expected caveat to have a value property of a non-empty object of snap IDs.',\n    ethErrors.rpc.invalidParams,\n  );\n}\n\nexport const SnapIdsCaveatSpecification: Record<\n  SnapCaveatType.SnapIds,\n  RestrictedMethodCaveatSpecificationConstraint\n> = {\n  [SnapCaveatType.SnapIds]: Object.freeze({\n    type: SnapCaveatType.SnapIds,\n    validator: (caveat) => validateSnapIdsCaveat(caveat),\n    decorator: (method, caveat) => {\n      return async (args) => {\n        const {\n          params,\n          context: { origin },\n        }: RestrictedMethodOptions<RestrictedMethodParameters> = args;\n        const snapIds = caveat.value;\n        const { snapId } = params as InvokeSnapParams;\n        if (!hasProperty(snapIds, snapId)) {\n          throw new Error(\n            `${origin} does not have permission to invoke ${snapId} snap.`,\n          );\n        }\n        return await method(args);\n      };\n    },\n  }),\n};\n"],"names":["snapIdsCaveatMapper","validateSnapIdsCaveat","SnapIdsCaveatSpecification","value","caveats","type","SnapCaveatType","SnapIds","caveat","assertStruct","SnapIdsStruct","ethErrors","rpc","invalidParams","Object","freeze","validator","decorator","method","args","params","context","origin","snapIds","snapId","hasProperty","Error"],"mappings":";;;;;;;;;;;IAwBgBA,mBAAmB;eAAnBA;;IAmBAC,qBAAqB;eAArBA;;IAaHC,0BAA0B;eAA1BA;;;4BAhDiC;uBAEJ;8BAChB;6BACL;AAYd,SAASF,oBACdG,KAAW;IAEX,OAAO;QACLC,SAAS;YACP;gBACEC,MAAMC,0BAAc,CAACC,OAAO;gBAC5BJ;YACF;SACD;IACH;AACF;AAQO,SAASF,sBACdO,MAA2B;IAE3BC,IAAAA,mBAAY,EACVD,QACAH,IAAAA,iBAAI,EAAC;QACHF,OAAOO,yBAAa;IACtB,IACA,+EACAC,uBAAS,CAACC,GAAG,CAACC,aAAa;AAE/B;AAEO,MAAMX,6BAGT;IACF,CAACI,0BAAc,CAACC,OAAO,CAAC,EAAEO,OAAOC,MAAM,CAAC;QACtCV,MAAMC,0BAAc,CAACC,OAAO;QAC5BS,WAAW,CAACR,SAAWP,sBAAsBO;QAC7CS,WAAW,CAACC,QAAQV;YAClB,OAAO,OAAOW;gBACZ,MAAM,EACJC,MAAM,EACNC,SAAS,EAAEC,MAAM,EAAE,EACpB,GAAwDH;gBACzD,MAAMI,UAAUf,OAAOL,KAAK;gBAC5B,MAAM,EAAEqB,MAAM,EAAE,GAAGJ;gBACnB,IAAI,CAACK,IAAAA,kBAAW,EAACF,SAASC,SAAS;oBACjC,MAAM,IAAIE,MACR,CAAC,EAAEJ,OAAO,oCAAoC,EAAEE,OAAO,MAAM,CAAC;gBAElE;gBACA,OAAO,MAAMN,OAAOC;YACtB;QACF;IACF;AACF"}