{"version":3,"sources":["../../src/utils.ts"],"sourcesContent":["import type { HardenedBIP32Node } from '@metamask/key-tree';\nimport { SLIP10Node } from '@metamask/key-tree';\nimport type { MagicValue } from '@metamask/snaps-utils';\nimport type { Hex } from '@metamask/utils';\nimport {\n  add0x,\n  assert,\n  concatBytes,\n  createDataView,\n  stringToBytes,\n} from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nconst HARDENED_VALUE = 0x80000000;\n\n/**\n * Maps an interface with method hooks to an object, using the keys of the\n * interface, and `true` as value. This ensures that the `methodHooks` object\n * has the same values as the interface.\n */\nexport type MethodHooksObject<HooksType extends Record<string, unknown>> = {\n  [Key in keyof HooksType]: true;\n};\n\n/**\n * Returns the subset of the specified `hooks` that are included in the\n * `hookNames` object. This is a Principle of Least Authority (POLA) measure\n * to ensure that each RPC method implementation only has access to the\n * API \"hooks\" it needs to do its job.\n *\n * @param hooks - The hooks to select from.\n * @param hookNames - The names of the hooks to select.\n * @returns The selected hooks.\n * @template Hooks - The hooks to select from.\n * @template HookName - The names of the hooks to select.\n */\nexport function selectHooks<\n  Hooks extends Record<string, unknown>,\n  HookName extends keyof Hooks,\n>(\n  hooks: Hooks,\n  hookNames?: Record<HookName, boolean>,\n): Pick<Hooks, HookName> | undefined {\n  if (hookNames) {\n    return Object.keys(hookNames).reduce<Partial<Pick<Hooks, HookName>>>(\n      (hookSubset, _hookName) => {\n        const hookName = _hookName as HookName;\n        hookSubset[hookName] = hooks[hookName];\n        return hookSubset;\n      },\n      {},\n    ) as Pick<Hooks, HookName>;\n  }\n  return undefined;\n}\n\n/**\n * Get a BIP-32 derivation path array from a hash, which is compatible with\n * `@metamask/key-tree`. The hash is assumed to be 32 bytes long.\n *\n * @param hash - The hash to derive indices from.\n * @returns The derived indices as a {@link HardenedBIP32Node} array.\n */\nfunction getDerivationPathArray(hash: Uint8Array): HardenedBIP32Node[] {\n  const array: HardenedBIP32Node[] = [];\n  const view = createDataView(hash);\n\n  for (let index = 0; index < 8; index++) {\n    const uint32 = view.getUint32(index * 4);\n\n    // This is essentially `index | 0x80000000`. Because JavaScript numbers are\n    // signed, we use the bitwise unsigned right shift operator to ensure that\n    // the result is a positive number.\n    // eslint-disable-next-line no-bitwise\n    const pathIndex = (uint32 | HARDENED_VALUE) >>> 0;\n    array.push(`bip32:${pathIndex - HARDENED_VALUE}'` as const);\n  }\n\n  return array;\n}\n\ntype DeriveEntropyOptions = {\n  /**\n   * The input value to derive entropy from.\n   */\n  input: string;\n\n  /**\n   * An optional salt to use when deriving entropy.\n   */\n  salt?: string;\n\n  /**\n   * The mnemonic phrase to use for entropy derivation.\n   */\n  mnemonicPhrase: Uint8Array;\n\n  /**\n   * A hardened BIP-32 index, which is used to derive the root key from the\n   * mnemonic phrase.\n   */\n  magic: MagicValue;\n};\n\n/**\n * Derive entropy from the given mnemonic phrase and salt.\n *\n * This is based on the reference implementation of\n * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).\n *\n * @param options - The options for entropy derivation.\n * @param options.input - The input value to derive entropy from.\n * @param options.salt - An optional salt to use when deriving entropy.\n * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy\n * derivation.\n * @param options.magic - A hardened BIP-32 index, which is used to derive the\n * root key from the mnemonic phrase.\n * @returns The derived entropy.\n */\nexport async function deriveEntropy({\n  input,\n  salt = '',\n  mnemonicPhrase,\n  magic,\n}: DeriveEntropyOptions): Promise<Hex> {\n  const inputBytes = stringToBytes(input);\n  const saltBytes = stringToBytes(salt);\n\n  // Get the derivation path from the snap ID.\n  const hash = keccak256(concatBytes([inputBytes, keccak256(saltBytes)]));\n  const computedDerivationPath = getDerivationPathArray(hash);\n\n  // Derive the private key using BIP-32.\n  const { privateKey } = await SLIP10Node.fromDerivationPath({\n    derivationPath: [\n      mnemonicPhrase,\n      `bip32:${magic}`,\n      ...computedDerivationPath,\n    ],\n    curve: 'secp256k1',\n  });\n\n  // This should never happen, but this keeps TypeScript happy.\n  assert(privateKey, 'Failed to derive the entropy.');\n\n  return add0x(privateKey);\n}\n"],"names":["selectHooks","deriveEntropy","HARDENED_VALUE","hooks","hookNames","Object","keys","reduce","hookSubset","_hookName","hookName","undefined","getDerivationPathArray","hash","array","view","createDataView","index","uint32","getUint32","pathIndex","push","input","salt","mnemonicPhrase","magic","inputBytes","stringToBytes","saltBytes","keccak256","concatBytes","computedDerivationPath","privateKey","SLIP10Node","fromDerivationPath","derivationPath","curve","assert","add0x"],"mappings":";;;;;;;;;;;IAoCgBA,WAAW;eAAXA;;IAmFMC,aAAa;eAAbA;;;yBAtHK;uBASpB;sBACiC;AAExC,MAAMC,iBAAiB;AAuBhB,SAASF,YAIdG,KAAY,EACZC,SAAqC;IAErC,IAAIA,WAAW;QACb,OAAOC,OAAOC,IAAI,CAACF,WAAWG,MAAM,CAClC,CAACC,YAAYC;YACX,MAAMC,WAAWD;YACjBD,UAAU,CAACE,SAAS,GAAGP,KAAK,CAACO,SAAS;YACtC,OAAOF;QACT,GACA,CAAC;IAEL;IACA,OAAOG;AACT;AAEA;;;;;;CAMC,GACD,SAASC,uBAAuBC,IAAgB;IAC9C,MAAMC,QAA6B,EAAE;IACrC,MAAMC,OAAOC,IAAAA,qBAAc,EAACH;IAE5B,IAAK,IAAII,QAAQ,GAAGA,QAAQ,GAAGA,QAAS;QACtC,MAAMC,SAASH,KAAKI,SAAS,CAACF,QAAQ;QAEtC,2EAA2E;QAC3E,0EAA0E;QAC1E,mCAAmC;QACnC,sCAAsC;QACtC,MAAMG,YAAY,AAACF,CAAAA,SAAShB,cAAa,MAAO;QAChDY,MAAMO,IAAI,CAAC,CAAC,MAAM,EAAED,YAAYlB,eAAe,CAAC,CAAC;IACnD;IAEA,OAAOY;AACT;AAwCO,eAAeb,cAAc,EAClCqB,KAAK,EACLC,OAAO,EAAE,EACTC,cAAc,EACdC,KAAK,EACgB;IACrB,MAAMC,aAAaC,IAAAA,oBAAa,EAACL;IACjC,MAAMM,YAAYD,IAAAA,oBAAa,EAACJ;IAEhC,4CAA4C;IAC5C,MAAMV,OAAOgB,IAAAA,gBAAS,EAACC,IAAAA,kBAAW,EAAC;QAACJ;QAAYG,IAAAA,gBAAS,EAACD;KAAW;IACrE,MAAMG,yBAAyBnB,uBAAuBC;IAEtD,uCAAuC;IACvC,MAAM,EAAEmB,UAAU,EAAE,GAAG,MAAMC,mBAAU,CAACC,kBAAkB,CAAC;QACzDC,gBAAgB;YACdX;YACA,CAAC,MAAM,EAAEC,MAAM,CAAC;eACbM;SACJ;QACDK,OAAO;IACT;IAEA,6DAA6D;IAC7DC,IAAAA,aAAM,EAACL,YAAY;IAEnB,OAAOM,IAAAA,YAAK,EAACN;AACf"}