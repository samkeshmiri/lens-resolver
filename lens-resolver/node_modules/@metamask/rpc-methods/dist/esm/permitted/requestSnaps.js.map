{"version":3,"sources":["../../../src/permitted/requestSnaps.ts"],"sourcesContent":["import type {\n  PermissionConstraint,\n  RequestedPermissions,\n  Caveat,\n} from '@metamask/permission-controller';\nimport type { SnapsPermissionRequest } from '@metamask/snaps-utils';\nimport {\n  SnapCaveatType,\n  verifyRequestedSnapPermissions,\n} from '@metamask/snaps-utils';\nimport type {\n  PermittedHandlerExport,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n  JsonRpcEngineEndCallback,\n} from '@metamask/types';\nimport type { Json } from '@metamask/utils';\nimport { hasProperty, isObject } from '@metamask/utils';\nimport { ethErrors } from 'eth-rpc-errors';\n\nimport { WALLET_SNAP_PERMISSION_KEY } from '../restricted/invokeSnap';\nimport type { MethodHooksObject } from '../utils';\nimport type {\n  InstallSnapsHook,\n  InstallSnapsResult,\n} from './common/snapInstallation';\nimport { handleInstallSnaps } from './common/snapInstallation';\n\nconst hookNames: MethodHooksObject<RequestSnapsHooks> = {\n  installSnaps: true,\n  requestPermissions: true,\n  getPermissions: true,\n};\n\n/**\n * `wallet_requestSnaps` installs the requested Snaps and requests permission to use them if necessary.\n */\nexport const requestSnapsHandler: PermittedHandlerExport<\n  RequestSnapsHooks,\n  RequestedPermissions,\n  InstallSnapsResult\n> = {\n  methodNames: ['wallet_requestSnaps'],\n  implementation: requestSnapsImplementation,\n  hookNames,\n};\n\nexport type RequestSnapsHooks = {\n  /**\n   * Installs the requested snaps if they are permitted.\n   */\n  installSnaps: InstallSnapsHook;\n\n  /**\n   * Initiates a permission request for the requesting origin.\n   *\n   * @returns The result of the permissions request.\n   */\n  requestPermissions: (\n    permissions: RequestedPermissions,\n  ) => Promise<\n    [\n      Record<string, PermissionConstraint>,\n      { data: Record<string, unknown>; id: string; origin: string },\n    ]\n  >;\n\n  /**\n   * Gets the current permissions for the requesting origin.\n   *\n   * @returns The current permissions of the requesting origin.\n   */\n  getPermissions: () => Promise<\n    Record<string, PermissionConstraint> | undefined\n  >;\n};\n\n/**\n * Checks whether an origin has existing `wallet_snap` permission and\n * whether or not it has the requested snapIds caveat.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedSnaps - The requested snaps.\n * @returns True if the existing permissions satisfy the requested snaps, otherwise false.\n */\nexport function hasRequestedSnaps(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedSnaps: Record<string, unknown>,\n): boolean {\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ]?.caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = snapIdCaveat?.value;\n  if (isObject(permittedSnaps)) {\n    return Object.keys(requestedSnaps).every((requestedSnap) =>\n      hasProperty(permittedSnaps, requestedSnap),\n    );\n  }\n  return false;\n}\n\n/**\n * Constructs a valid permission request with merged caveats based on existing permissions\n * and the requested snaps.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedPermissions - The permission request passed into `requestPermissions`.\n * @returns `requestedPermissions`.\n */\nexport function getSnapPermissionsRequest(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedPermissions: unknown,\n): SnapsPermissionRequest {\n  verifyRequestedSnapPermissions(requestedPermissions);\n\n  if (!existingPermissions[WALLET_SNAP_PERMISSION_KEY]) {\n    return requestedPermissions;\n  }\n\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ].caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = (snapIdCaveat?.value as Record<string, Json>) ?? {};\n\n  const requestedSnaps =\n    requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value;\n\n  const snapIdSet = new Set([\n    ...Object.keys(permittedSnaps),\n    ...Object.keys(requestedSnaps),\n  ]);\n\n  const mergedCaveatValue = [...snapIdSet].reduce<Record<string, Json>>(\n    (request, snapId) => {\n      request[snapId] = requestedSnaps[snapId] ?? permittedSnaps[snapId];\n      return request;\n    },\n    {},\n  );\n\n  requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value =\n    mergedCaveatValue;\n\n  return requestedPermissions;\n}\n\n/**\n * The `wallet_requestSnaps` method implementation.\n * Tries to install the requested snaps and adds them to the JSON-RPC response.\n *\n * @param req - The JSON-RPC request object.\n * @param res - The JSON-RPC response object.\n * @param _next - The `json-rpc-engine` \"next\" callback. Not used by this\n * function.\n * @param end - The `json-rpc-engine` \"end\" callback.\n * @param hooks - The RPC method hooks.\n * @param hooks.installSnaps - A function that tries to install a given snap, prompting the user if necessary.\n * @param hooks.requestPermissions - A function that requests permissions on\n * behalf of a subject.\n * @param hooks.getPermissions - A function that gets the current permissions.\n * @returns A promise that resolves once the JSON-RPC response has been modified.\n * @throws If the params are invalid.\n */\nasync function requestSnapsImplementation(\n  req: JsonRpcRequest<RequestedPermissions>,\n  res: PendingJsonRpcResponse<InstallSnapsResult>,\n  _next: unknown,\n  end: JsonRpcEngineEndCallback,\n  { installSnaps, requestPermissions, getPermissions }: RequestSnapsHooks,\n): Promise<void> {\n  const requestedSnaps = req.params;\n  if (!isObject(requestedSnaps)) {\n    return end(\n      ethErrors.rpc.invalidParams({\n        message: '\"params\" must be an object.',\n      }),\n    );\n  }\n\n  try {\n    if (!Object.keys(requestedSnaps).length) {\n      throw new Error('Request must have at least one requested snap.');\n    }\n\n    const requestedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [{ type: SnapCaveatType.SnapIds, value: requestedSnaps }],\n      },\n    } as RequestedPermissions;\n    const existingPermissions = await getPermissions();\n\n    if (!existingPermissions) {\n      const [, metadata] = await requestPermissions(requestedPermissions);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as InstallSnapsResult;\n    } else if (hasRequestedSnaps(existingPermissions, requestedSnaps)) {\n      res.result = await handleInstallSnaps(requestedSnaps, installSnaps);\n    } else {\n      const mergedPermissionsRequest = getSnapPermissionsRequest(\n        existingPermissions,\n        requestedPermissions,\n      );\n\n      const [, metadata] = await requestPermissions(mergedPermissionsRequest);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as InstallSnapsResult;\n    }\n  } catch (error) {\n    res.error = error;\n  }\n\n  return end();\n}\n"],"names":["SnapCaveatType","verifyRequestedSnapPermissions","hasProperty","isObject","ethErrors","WALLET_SNAP_PERMISSION_KEY","handleInstallSnaps","hookNames","installSnaps","requestPermissions","getPermissions","requestSnapsHandler","methodNames","implementation","requestSnapsImplementation","hasRequestedSnaps","existingPermissions","requestedSnaps","snapIdCaveat","caveats","find","caveat","type","SnapIds","permittedSnaps","value","Object","keys","every","requestedSnap","getSnapPermissionsRequest","requestedPermissions","snapIdSet","Set","mergedCaveatValue","reduce","request","snapId","req","res","_next","end","params","rpc","invalidParams","message","length","Error","metadata","result","data","mergedPermissionsRequest","error"],"mappings":"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"}