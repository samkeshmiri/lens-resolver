{"version":3,"sources":["../../../src/common/BaseSnapExecutor.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\n/// <reference path=\"../../../../node_modules/ses/index.d.ts\" />\nimport { StreamProvider } from '@metamask/providers';\nimport type { RequestArguments } from '@metamask/providers/dist/BaseProvider';\nimport type { SnapsGlobalObject } from '@metamask/rpc-methods';\nimport type {\n  SnapExports,\n  HandlerType,\n  SnapExportsParameters,\n} from '@metamask/snaps-utils';\nimport { SNAP_EXPORT_NAMES, logError } from '@metamask/snaps-utils';\nimport type {\n  JsonRpcNotification,\n  JsonRpcId,\n  JsonRpcRequest,\n  Json,\n} from '@metamask/utils';\nimport {\n  isObject,\n  isValidJson,\n  assert,\n  isJsonRpcRequest,\n  hasProperty,\n  getSafeJson,\n} from '@metamask/utils';\nimport { errorCodes, ethErrors, serializeError } from 'eth-rpc-errors';\nimport { createIdRemapMiddleware } from 'json-rpc-engine';\nimport type { Duplex } from 'stream';\nimport { validate } from 'superstruct';\n\nimport { log } from '../logging';\nimport EEOpenRPCDocument from '../openrpc.json';\nimport type { CommandMethodsMapping } from './commands';\nimport { getCommandMethodImplementations } from './commands';\nimport { createEndowments } from './endowments';\nimport { addEventListener, removeEventListener } from './globalEvents';\nimport { sortParamKeys } from './sortParams';\nimport {\n  assertEthereumOutboundRequest,\n  assertSnapOutboundRequest,\n  constructError,\n  proxyStreamProvider,\n  withTeardown,\n} from './utils';\nimport {\n  ExecuteSnapRequestArgumentsStruct,\n  PingRequestArgumentsStruct,\n  SnapRpcRequestArgumentsStruct,\n  TerminateRequestArgumentsStruct,\n  validateExport,\n} from './validation';\n\ntype EvaluationData = {\n  stop: () => void;\n};\n\ntype SnapData = {\n  exports: SnapExports;\n  runningEvaluations: Set<EvaluationData>;\n  idleTeardown: () => Promise<void>;\n};\n\nconst fallbackError = {\n  code: errorCodes.rpc.internal,\n  message: 'Execution Environment Error',\n};\n\nexport type InvokeSnapArgs = Omit<SnapExportsParameters[0], 'chainId'>;\n\nexport type InvokeSnap = (\n  target: string,\n  handler: HandlerType,\n  args: InvokeSnapArgs | undefined,\n) => Promise<Json>;\n\n/**\n * The supported methods in the execution environment. The validator checks the\n * incoming JSON-RPC request, and the `params` property is used for sorting the\n * parameters, if they are an object.\n */\nconst EXECUTION_ENVIRONMENT_METHODS = {\n  ping: {\n    struct: PingRequestArgumentsStruct,\n    params: [],\n  },\n  executeSnap: {\n    struct: ExecuteSnapRequestArgumentsStruct,\n    params: ['snapId', 'sourceCode', 'endowments'],\n  },\n  terminate: {\n    struct: TerminateRequestArgumentsStruct,\n    params: [],\n  },\n  snapRpc: {\n    struct: SnapRpcRequestArgumentsStruct,\n    params: ['target', 'handler', 'origin', 'request'],\n  },\n};\n\ntype Methods = typeof EXECUTION_ENVIRONMENT_METHODS;\n\nexport class BaseSnapExecutor {\n  private readonly snapData: Map<string, SnapData>;\n\n  private readonly commandStream: Duplex;\n\n  private readonly rpcStream: Duplex;\n\n  private readonly methods: CommandMethodsMapping;\n\n  private snapErrorHandler?: (event: ErrorEvent) => void;\n\n  private snapPromiseErrorHandler?: (event: PromiseRejectionEvent) => void;\n\n  private lastTeardown = 0;\n\n  protected constructor(commandStream: Duplex, rpcStream: Duplex) {\n    this.snapData = new Map();\n    this.commandStream = commandStream;\n    this.commandStream.on('data', (data) => {\n      this.onCommandRequest(data).catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n    });\n    this.rpcStream = rpcStream;\n\n    this.methods = getCommandMethodImplementations(\n      this.startSnap.bind(this),\n      async (target, handlerName, args) => {\n        const data = this.snapData.get(target);\n        // We're capturing the handler in case someone modifies the data object before the call\n        const handler = data?.exports[handlerName];\n        assert(\n          handler !== undefined,\n          `No ${handlerName} handler exported for snap \"${target}`,\n        );\n        // TODO: fix handler args type cast\n        let result = await this.executeInSnapContext(target, () =>\n          handler(args as any),\n        );\n\n        // The handler might not return anything, but undefined is not valid JSON.\n        if (result === undefined) {\n          result = null;\n        }\n\n        // /!\\ Always return only sanitized JSON to prevent security flaws. /!\\\n        try {\n          return getSafeJson(result);\n        } catch (error) {\n          throw new TypeError(\n            `Received non-JSON-serializable value: ${error.message.replace(\n              /^Assertion failed: /u,\n              '',\n            )}`,\n          );\n        }\n      },\n      this.onTerminate.bind(this),\n    );\n  }\n\n  private errorHandler(error: unknown, data: Record<string, Json>) {\n    const constructedError = constructError(error);\n    const serializedError = serializeError(constructedError, {\n      fallbackError,\n      shouldIncludeStack: false,\n    });\n\n    // We're setting it this way to avoid sentData.stack = undefined\n    const sentData: Json = { ...data, stack: constructedError?.stack ?? null };\n\n    this.notify({\n      method: 'UnhandledError',\n      params: {\n        error: {\n          ...serializedError,\n          data: sentData,\n        },\n      },\n    });\n  }\n\n  private async onCommandRequest(message: JsonRpcRequest) {\n    if (!isJsonRpcRequest(message)) {\n      throw new Error('Command stream received a non-JSON-RPC request.');\n    }\n\n    const { id, method, params } = message;\n    if (method === 'rpc.discover') {\n      this.respond(id, {\n        result: EEOpenRPCDocument,\n      });\n      return;\n    }\n\n    if (!hasProperty(EXECUTION_ENVIRONMENT_METHODS, method)) {\n      this.respond(id, {\n        error: ethErrors.rpc\n          .methodNotFound({\n            data: {\n              method,\n            },\n          })\n          .serialize(),\n      });\n      return;\n    }\n\n    const methodObject = EXECUTION_ENVIRONMENT_METHODS[method as keyof Methods];\n\n    // support params by-name and by-position\n    const paramsAsArray = sortParamKeys(methodObject.params, params);\n\n    const [error] = validate<any, any>(paramsAsArray, methodObject.struct);\n    if (error) {\n      this.respond(id, {\n        error: ethErrors.rpc\n          .invalidParams({\n            message: `Invalid parameters for method \"${method}\": ${error.message}.`,\n            data: {\n              method,\n              params: paramsAsArray,\n            },\n          })\n          .serialize(),\n      });\n      return;\n    }\n\n    try {\n      const result = await (this.methods as any)[method](...paramsAsArray);\n      this.respond(id, { result });\n    } catch (rpcError) {\n      this.respond(id, {\n        error: serializeError(rpcError, {\n          fallbackError,\n        }),\n      });\n    }\n  }\n\n  protected notify(requestObject: Omit<JsonRpcNotification, 'jsonrpc'>) {\n    if (!isValidJson(requestObject) || !isObject(requestObject)) {\n      throw new Error(\n        'JSON-RPC notifications must be JSON serializable objects',\n      );\n    }\n\n    this.commandStream.write({\n      ...requestObject,\n      jsonrpc: '2.0',\n    });\n  }\n\n  protected respond(id: JsonRpcId, requestObject: Record<string, unknown>) {\n    if (!isValidJson(requestObject) || !isObject(requestObject)) {\n      throw new Error('JSON-RPC responses must be JSON serializable objects.');\n    }\n\n    this.commandStream.write({\n      ...requestObject,\n      id,\n      jsonrpc: '2.0',\n    });\n  }\n\n  /**\n   * Attempts to evaluate a snap in SES. Generates APIs for the snap. May throw\n   * on errors.\n   *\n   * @param snapId - The id of the snap.\n   * @param sourceCode - The source code of the snap, in IIFE format.\n   * @param _endowments - An array of the names of the endowments.\n   */\n  protected async startSnap(\n    snapId: string,\n    sourceCode: string,\n    _endowments?: string[],\n  ): Promise<void> {\n    log(`Starting snap '${snapId}' in worker.`);\n    if (this.snapPromiseErrorHandler) {\n      removeEventListener('unhandledrejection', this.snapPromiseErrorHandler);\n    }\n\n    if (this.snapErrorHandler) {\n      removeEventListener('error', this.snapErrorHandler);\n    }\n\n    this.snapErrorHandler = (error: ErrorEvent) => {\n      this.errorHandler(error.error, { snapId });\n    };\n\n    this.snapPromiseErrorHandler = (error: PromiseRejectionEvent) => {\n      this.errorHandler(error instanceof Error ? error : error.reason, {\n        snapId,\n      });\n    };\n\n    const provider = new StreamProvider(this.rpcStream, {\n      jsonRpcStreamName: 'metamask-provider',\n      rpcMiddleware: [createIdRemapMiddleware()],\n    });\n\n    await provider.initialize();\n\n    const snap = this.createSnapGlobal(provider);\n    const ethereum = this.createEIP1193Provider(provider);\n    // We specifically use any type because the Snap can modify the object any way they want\n    const snapModule: any = { exports: {} };\n\n    try {\n      const { endowments, teardown: endowmentTeardown } = createEndowments(\n        snap,\n        ethereum,\n        snapId,\n        _endowments,\n      );\n\n      // !!! Ensure that this is the only place the data is being set.\n      // Other methods access the object value and mutate its properties.\n      this.snapData.set(snapId, {\n        idleTeardown: endowmentTeardown,\n        runningEvaluations: new Set(),\n        exports: {},\n      });\n\n      addEventListener('unhandledRejection', this.snapPromiseErrorHandler);\n      addEventListener('error', this.snapErrorHandler);\n\n      const compartment = new Compartment({\n        ...endowments,\n        module: snapModule,\n        exports: snapModule.exports,\n      });\n      // All of those are JavaScript runtime specific and self referential,\n      // but we add them for compatibility sake with external libraries.\n      //\n      // We can't do that in the injected globals object above\n      // because SES creates its own globalThis\n      compartment.globalThis.self = compartment.globalThis;\n      compartment.globalThis.global = compartment.globalThis;\n      compartment.globalThis.window = compartment.globalThis;\n\n      await this.executeInSnapContext(snapId, () => {\n        compartment.evaluate(sourceCode);\n        this.registerSnapExports(snapId, snapModule);\n      });\n    } catch (error) {\n      this.removeSnap(snapId);\n      throw new Error(\n        `Error while running snap '${snapId}': ${(error as Error).message}`,\n      );\n    }\n  }\n\n  /**\n   * Cancels all running evaluations of all snaps and clears all snap data.\n   * NOTE:** Should only be called in response to the `terminate` RPC command.\n   */\n  protected onTerminate() {\n    // `stop()` tears down snap endowments.\n    // Teardown will also be run for each snap as soon as there are\n    // no more running evaluations for that snap.\n    this.snapData.forEach((data) =>\n      data.runningEvaluations.forEach((evaluation) => evaluation.stop()),\n    );\n    this.snapData.clear();\n  }\n\n  private registerSnapExports(snapId: string, snapModule: any) {\n    const data = this.snapData.get(snapId);\n    // Somebody deleted the Snap before we could register\n    if (!data) {\n      return;\n    }\n\n    data.exports = SNAP_EXPORT_NAMES.reduce((acc, exportName) => {\n      const snapExport = snapModule.exports[exportName];\n      if (validateExport(exportName, snapExport)) {\n        return { ...acc, [exportName]: snapExport };\n      }\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Instantiates a snap API object (i.e. `globalThis.snap`).\n   *\n   * @param provider - A StreamProvider connected to MetaMask.\n   * @returns The snap provider object.\n   */\n  private createSnapGlobal(provider: StreamProvider): SnapsGlobalObject {\n    const originalRequest = provider.request.bind(provider);\n\n    const request = async (args: RequestArguments) => {\n      assertSnapOutboundRequest(args);\n      const sanitizedArgs = getSafeJson(args);\n      this.notify({ method: 'OutboundRequest' });\n      try {\n        return await withTeardown(\n          originalRequest(sanitizedArgs as unknown as RequestArguments),\n          this as any,\n        );\n      } finally {\n        this.notify({ method: 'OutboundResponse' });\n      }\n    };\n\n    // Proxy target is intentionally set to be an empty object, to ensure\n    // that access to the prototype chain is not possible.\n    const snapGlobalProxy = new Proxy(\n      {},\n      {\n        has(_target: object, prop: string | symbol) {\n          return typeof prop === 'string' && ['request'].includes(prop);\n        },\n        get(_target, prop: keyof StreamProvider) {\n          if (prop === 'request') {\n            return request;\n          }\n\n          return undefined;\n        },\n      },\n    ) as SnapsGlobalObject;\n\n    return harden(snapGlobalProxy);\n  }\n\n  /**\n   * Instantiates an EIP-1193 Ethereum provider object (i.e. `globalThis.ethereum`).\n   *\n   * @param provider - A StreamProvider connected to MetaMask.\n   * @returns The EIP-1193 Ethereum provider object.\n   */\n  private createEIP1193Provider(provider: StreamProvider): StreamProvider {\n    const originalRequest = provider.request.bind(provider);\n\n    const request = async (args: RequestArguments) => {\n      assertEthereumOutboundRequest(args);\n      const sanitizedArgs = getSafeJson(args);\n      this.notify({ method: 'OutboundRequest' });\n      try {\n        return await withTeardown(\n          originalRequest(sanitizedArgs as unknown as RequestArguments),\n          this as any,\n        );\n      } finally {\n        this.notify({ method: 'OutboundResponse' });\n      }\n    };\n\n    const streamProviderProxy = proxyStreamProvider(provider, request);\n\n    return harden(streamProviderProxy);\n  }\n\n  /**\n   * Removes the snap with the given name.\n   *\n   * @param snapId - The id of the snap to remove.\n   */\n  private removeSnap(snapId: string): void {\n    this.snapData.delete(snapId);\n  }\n\n  /**\n   * Calls the specified executor function in the context of the specified snap.\n   * Essentially, this means that the operation performed by the executor is\n   * counted as an evaluation of the specified snap. When the count of running\n   * evaluations of a snap reaches zero, its endowments are torn down.\n   *\n   * @param snapId - The id of the snap whose context to execute in.\n   * @param executor - The function that will be executed in the snap's context.\n   * @returns The executor's return value.\n   * @template Result - The return value of the executor.\n   */\n  private async executeInSnapContext<Result>(\n    snapId: string,\n    executor: () => Promise<Result> | Result,\n  ): Promise<Result> {\n    const data = this.snapData.get(snapId);\n    if (data === undefined) {\n      throw new Error(\n        `Tried to execute in context of unknown snap: \"${snapId}\".`,\n      );\n    }\n\n    let stop: () => void;\n    const stopPromise = new Promise<never>(\n      (_, reject) =>\n        (stop = () =>\n          reject(\n            // TODO(rekmarks): Specify / standardize error code for this case.\n            ethErrors.rpc.internal(\n              `The snap \"${snapId}\" has been terminated during execution.`,\n            ),\n          )),\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const evaluationData = { stop: stop! };\n\n    try {\n      data.runningEvaluations.add(evaluationData);\n      // Notice that we have to await this executor.\n      // If we didn't, we would decrease the amount of running evaluations\n      // before the promise actually resolves\n      return await Promise.race([executor(), stopPromise]);\n    } finally {\n      data.runningEvaluations.delete(evaluationData);\n\n      if (data.runningEvaluations.size === 0) {\n        this.lastTeardown += 1;\n        await data.idleTeardown();\n      }\n    }\n  }\n}\n"],"names":["StreamProvider","SNAP_EXPORT_NAMES","logError","isObject","isValidJson","assert","isJsonRpcRequest","hasProperty","getSafeJson","errorCodes","ethErrors","serializeError","createIdRemapMiddleware","validate","log","EEOpenRPCDocument","getCommandMethodImplementations","createEndowments","addEventListener","removeEventListener","sortParamKeys","assertEthereumOutboundRequest","assertSnapOutboundRequest","constructError","proxyStreamProvider","withTeardown","ExecuteSnapRequestArgumentsStruct","PingRequestArgumentsStruct","SnapRpcRequestArgumentsStruct","TerminateRequestArgumentsStruct","validateExport","fallbackError","code","rpc","internal","message","EXECUTION_ENVIRONMENT_METHODS","ping","struct","params","executeSnap","terminate","snapRpc","BaseSnapExecutor","errorHandler","error","data","constructedError","serializedError","shouldIncludeStack","sentData","stack","notify","method","onCommandRequest","Error","id","respond","result","methodNotFound","serialize","methodObject","paramsAsArray","invalidParams","methods","rpcError","requestObject","commandStream","write","jsonrpc","startSnap","snapId","sourceCode","_endowments","snapPromiseErrorHandler","snapErrorHandler","reason","provider","rpcStream","jsonRpcStreamName","rpcMiddleware","initialize","snap","createSnapGlobal","ethereum","createEIP1193Provider","snapModule","exports","endowments","teardown","endowmentTeardown","snapData","set","idleTeardown","runningEvaluations","Set","compartment","Compartment","module","globalThis","self","global","window","executeInSnapContext","evaluate","registerSnapExports","removeSnap","onTerminate","forEach","evaluation","stop","clear","get","reduce","acc","exportName","snapExport","originalRequest","request","bind","args","sanitizedArgs","snapGlobalProxy","Proxy","has","_target","prop","includes","undefined","harden","streamProviderProxy","delete","executor","stopPromise","Promise","_","reject","evaluationData","add","race","size","lastTeardown","Map","on","catch","target","handlerName","handler","TypeError","replace"],"mappings":"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"}